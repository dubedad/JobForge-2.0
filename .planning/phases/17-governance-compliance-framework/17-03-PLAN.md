---
phase: 17-governance-compliance-framework
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - data/catalog/policy_mappings.json
  - src/jobforge/governance/policy/mappings.py
  - src/jobforge/governance/policy/loader.py
  - tests/governance/policy/test_mappings.py
autonomous: true

must_haves:
  truths:
    - "Policy mappings stored in data/catalog/policy_mappings.json"
    - "Mappings cover tables, columns, and relationships"
    - "Loader provides bidirectional lookup (element->policies, policy->elements)"
    - "Catalog JSON files can store policy_refs field"
  artifacts:
    - path: "data/catalog/policy_mappings.json"
      provides: "Central policy-to-data mappings file"
      contains: "element_type"
    - path: "src/jobforge/governance/policy/mappings.py"
      provides: "Policy mapping creation and validation"
      exports: ["create_mapping", "validate_mapping", "generate_initial_mappings"]
    - path: "src/jobforge/governance/policy/loader.py"
      provides: "Load and query policy mappings"
      exports: ["PolicyMappingLoader"]
  key_links:
    - from: "src/jobforge/governance/policy/loader.py"
      to: "data/catalog/policy_mappings.json"
      via: "json.load"
      pattern: "read_text.*policy_mappings"
    - from: "src/jobforge/governance/policy/mappings.py"
      to: "src/jobforge/governance/policy/models.py"
      via: "import"
      pattern: "from.*models import.*PolicyMapping"
---

<objective>
Create the policy mappings data layer with storage, loader, and initial mappings generation.

Purpose: Stores policy-to-data traceability with three-level granularity (table, column, relationship) in a central JSON file. Enables bidirectional queries required by CONTEXT.md decisions.

Output: policy_mappings.json with initial mappings, PolicyMappingLoader for queries, mapping generators.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-governance-compliance-framework/17-CONTEXT.md
@.planning/phases/17-governance-compliance-framework/17-RESEARCH.md
@.planning/phases/17-governance-compliance-framework/17-01-SUMMARY.md
@src/jobforge/governance/policy/models.py
@data/catalog/tables/dim_noc.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PolicyMappingLoader with bidirectional queries</name>
  <files>src/jobforge/governance/policy/loader.py, tests/governance/policy/test_loader.py</files>
  <action>
Create PolicyMappingLoader class that:
1. Loads policy_mappings.json from data/catalog/policy_mappings.json
2. Provides get_policies_for_element(element_path: str) -> list[PolicyMapping]
   - Returns all mappings where element_path matches or starts with input
   - e.g., "dim_noc" returns table + all column mappings for dim_noc
3. Provides get_elements_for_policy(policy_source: PolicySource, clause_id: str) -> list[str]
   - Returns element_paths that satisfy the given policy clause
4. Provides get_all_mappings() -> list[PolicyMapping]
5. Provides get_mappings_by_status(status: ComplianceStatus) -> list[PolicyMapping]
6. Caches loaded mappings (lazy load on first access)

Handle gracefully if policy_mappings.json doesn't exist yet (return empty list).

Write tests covering:
- Load from file
- Empty file handling
- Bidirectional queries
- Status filtering
  </action>
  <verify>pytest tests/governance/policy/test_loader.py -v</verify>
  <done>PolicyMappingLoader supports bidirectional queries for policy-to-element and element-to-policy lookups</done>
</task>

<task type="auto">
  <name>Task 2: Create mapping generators and initial mappings file</name>
  <files>src/jobforge/governance/policy/mappings.py, data/catalog/policy_mappings.json</files>
  <action>
Create mappings.py with:
1. create_mapping(element_type, element_path, primary_policy, ...) -> PolicyMapping
   - Convenience function with defaults
2. validate_mapping(mapping: PolicyMapping) -> list[str]
   - Returns list of validation errors (empty if valid)
   - Checks na_reason required when NOT_APPLICABLE
3. generate_initial_mappings() -> list[PolicyMapping]
   - Generates mappings for core WiQ tables to TBS DSD and DAMA clauses
   - Cover at minimum:
     - dim_noc (table): DAMA-9 (Reference Data), TBS-DSD-6.1 (data governance)
     - dim_noc.unit_group_id (column): DAMA-7 (Metadata)
     - dim_noc->cops_employment (relationship): DAMA-6 (Integration)
     - dim_occupations (table): DAMA-9, TBS-DSD-6.1
     - job_architecture (table): DAMA-3 (Modeling)
     - data/catalog/lineage/*.json: DAMA-7 (Metadata)
   - Generate 20-30 initial mappings covering Phase 16 + core tables
4. save_mappings(mappings: list[PolicyMapping], path: Path) -> None

Create data/catalog/policy_mappings.json by running generate_initial_mappings() and save_mappings().

Use version_date of 2024-04-01 for TBS DSD, 2017-01-01 for DAMA DMBOK.
  </action>
  <verify>
python -c "
from jobforge.governance.policy.loader import PolicyMappingLoader
loader = PolicyMappingLoader()
mappings = loader.get_all_mappings()
print(f'Total mappings: {len(mappings)}')
for m in mappings[:5]:
    print(f'  {m.element_type.value}: {m.element_path} -> {m.primary_policy.clause_id}')
"
  </verify>
  <done>policy_mappings.json exists with 20+ initial mappings covering core WiQ tables</done>
</task>

<task type="auto">
  <name>Task 3: Add policy_refs field support to catalog enrichment</name>
  <files>src/jobforge/catalog/enrich.py, tests/catalog/test_enrich_policy.py</files>
  <action>
Extend src/jobforge/catalog/enrich.py to support policy_refs in catalog JSON:

1. Add add_policy_refs(table_metadata: dict, table_name: str) -> dict
   - Looks up PolicyMappingLoader for this table
   - Adds "policy_refs" field with list of {policy_source, clause_id, compliance_status}
   - Returns updated metadata dict

2. Update existing enrich functions to optionally include policy_refs:
   - If policy mappings exist for table, add policy_refs field
   - Don't fail if no mappings (just skip policy_refs)

Write tests to verify:
- policy_refs added when mappings exist
- Empty policy_refs when no mappings
- Correct structure of policy_refs entries
  </action>
  <verify>pytest tests/catalog/test_enrich_policy.py -v</verify>
  <done>Catalog enrichment can add policy_refs field to table metadata</done>
</task>

</tasks>

<verification>
```bash
# All policy mapping tests pass
pytest tests/governance/policy/ -v

# policy_mappings.json exists and has content
python -c "
import json
from pathlib import Path
data = json.loads(Path('data/catalog/policy_mappings.json').read_text())
print(f'Mappings file has {len(data)} entries')
"

# Bidirectional queries work
python -c "
from jobforge.governance.policy.loader import PolicyMappingLoader
from jobforge.governance.policy.models import PolicySource
loader = PolicyMappingLoader()

# Element to policy
policies = loader.get_policies_for_element('dim_noc')
print(f'dim_noc has {len(policies)} policy mappings')

# Policy to elements
elements = loader.get_elements_for_policy(PolicySource.DAMA_DMBOK, 'DAMA-9')
print(f'DAMA-9 governs {len(elements)} elements')
"
```
</verification>

<success_criteria>
- policy_mappings.json has 20+ mappings covering core tables
- PolicyMappingLoader provides bidirectional queries
- Catalog enrichment supports policy_refs field
- All mappings have version_date and compliance_status
- Tests pass (expect 15+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/17-governance-compliance-framework/17-03-SUMMARY.md`
</output>
