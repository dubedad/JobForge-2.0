---
phase: 05-data-governance-lineage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jobforge/governance/__init__.py
  - src/jobforge/governance/graph.py
  - src/jobforge/governance/models.py
  - pyproject.toml
  - tests/test_lineage_graph.py
autonomous: true

must_haves:
  truths:
    - "LineageGraph loads all transition logs from catalog/lineage/"
    - "LineageGraph builds a NetworkX DAG from transition logs"
    - "get_upstream returns full ancestry (staged -> bronze -> silver -> gold)"
    - "get_downstream returns full dependents"
    - "get_path returns transformation path between tables"
  artifacts:
    - path: "src/jobforge/governance/graph.py"
      provides: "LineageGraph class with NetworkX DAG"
      exports: ["LineageGraph"]
    - path: "src/jobforge/governance/models.py"
      provides: "Pydantic models for lineage nodes and edges"
      exports: ["LineageNode", "LineageEdge"]
    - path: "tests/test_lineage_graph.py"
      provides: "Tests for graph building and traversal"
      min_lines: 50
  key_links:
    - from: "src/jobforge/governance/graph.py"
      to: "data/catalog/lineage/*.json"
      via: "config.catalog_lineage_path()"
      pattern: "catalog_lineage_path"
    - from: "src/jobforge/governance/graph.py"
      to: "networkx"
      via: "nx.DiGraph"
      pattern: "nx\\.DiGraph"
---

<objective>
Build LineageGraph class that aggregates transition logs into a queryable NetworkX DAG.

Purpose: Enable lineage traversal (upstream/downstream queries) by building an in-memory graph from existing transition JSON logs. This is the foundation for CONV-01 (conversational lineage queries).

Output: `src/jobforge/governance/` module with LineageGraph class that loads 130+ transition logs and provides graph traversal methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-data-governance-lineage/05-RESEARCH.md

# Existing infrastructure
@src/jobforge/pipeline/models.py - LayerTransitionLog model
@src/jobforge/pipeline/config.py - PipelineConfig with catalog_lineage_path()
@src/jobforge/pipeline/catalog.py - CatalogManager with get_lineage_logs()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add networkx dependency and create governance module</name>
  <files>
    pyproject.toml
    src/jobforge/governance/__init__.py
    src/jobforge/governance/models.py
  </files>
  <action>
1. Add networkx>=3.0 to dependencies in pyproject.toml (after rich)

2. Create `src/jobforge/governance/__init__.py`:
   - Export LineageGraph (will be implemented in Task 2)
   - Export models (LineageNode, LineageEdge)

3. Create `src/jobforge/governance/models.py` with Pydantic models:
   - `LineageNode`: Represents a table at a layer
     - node_id: str (format: "{layer}.{table_name}")
     - layer: str (staged, bronze, silver, gold)
     - table_name: str
     - row_count: int | None
     - transforms: list[str]
   - `LineageEdge`: Represents a transition
     - source_node: str
     - target_node: str
     - transition_id: str
     - transforms: list[str]
     - timestamp: datetime

Follow existing Pydantic patterns from src/jobforge/pipeline/models.py (ConfigDict, Field with descriptions).
  </action>
  <verify>
    python -c "from jobforge.governance.models import LineageNode, LineageEdge; print('Models OK')"
  </verify>
  <done>
    - networkx added to pyproject.toml dependencies
    - governance module exists with __init__.py
    - LineageNode and LineageEdge models defined with proper types
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LineageGraph class with NetworkX DAG</name>
  <files>src/jobforge/governance/graph.py</files>
  <action>
Create `src/jobforge/governance/graph.py` with LineageGraph class:

```python
class LineageGraph:
    """Aggregates transition logs into queryable DAG."""

    def __init__(self, config: PipelineConfig):
        self.config = config
        self._graph: nx.DiGraph | None = None

    def build_graph(self) -> nx.DiGraph:
        """Build DAG from all transition log JSON files.

        Deduplicates by logical path (source_layer + target_layer + target_table),
        keeping only the most recent transition for each path.
        """
        # Implementation per RESEARCH.md Pattern 1

    @property
    def graph(self) -> nx.DiGraph:
        """Lazy-load graph on first access."""
        if self._graph is None:
            self._graph = self.build_graph()
        return self._graph

    def get_upstream(self, table: str, layer: str = "gold") -> list[str]:
        """Get all upstream dependencies using nx.ancestors()."""

    def get_downstream(self, table: str, layer: str = "staged") -> list[str]:
        """Get all downstream dependents using nx.descendants()."""

    def get_path(self, source_table: str, target_table: str) -> list[str]:
        """Get transformation path between tables using nx.shortest_path()."""

    def get_node_metadata(self, node_id: str) -> LineageNode | None:
        """Get metadata for a specific node."""

    def is_valid_dag(self) -> bool:
        """Check if graph is a valid DAG (no cycles)."""
        return nx.is_directed_acyclic_graph(self.graph)
```

Key implementation details:
- Load transitions using CatalogManager.get_lineage_logs() or direct JSON glob
- Node ID format: "{layer}.{table_name}" (e.g., "gold.dim_noc")
- Deduplicate by logical path, keeping most recent (sort by started_at desc)
- Store node metadata (row_count, transforms) as node attributes
- Store edge metadata (transition_id, transforms) as edge attributes
- Use pathlib.Path.stem to extract table name from file paths
  </action>
  <verify>
    python -c "from jobforge.governance.graph import LineageGraph; from jobforge.pipeline.config import PipelineConfig; g = LineageGraph(PipelineConfig()); g.build_graph(); print(f'Nodes: {len(g.graph.nodes)}, Edges: {len(g.graph.edges)}')"
  </verify>
  <done>
    - LineageGraph class builds NetworkX DAG from transition logs
    - get_upstream/get_downstream/get_path methods work
    - Graph has nodes for each table at each layer
    - Edges connect source to target with transition metadata
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for LineageGraph</name>
  <files>tests/test_lineage_graph.py</files>
  <action>
Create `tests/test_lineage_graph.py` with tests:

1. Test graph building:
   - test_build_graph_creates_nodes: Verify nodes exist for tables
   - test_build_graph_creates_edges: Verify edges connect layers
   - test_is_valid_dag: Verify no cycles

2. Test traversal:
   - test_get_upstream_returns_ancestors: For a gold table, returns staged/bronze/silver ancestors
   - test_get_downstream_returns_descendants: For a staged table, returns bronze/silver/gold descendants
   - test_get_path_returns_transformation_chain: Verify path from staged to gold

3. Test edge cases:
   - test_get_upstream_unknown_table_returns_empty: Graceful handling
   - test_get_path_no_path_returns_empty: When tables are unconnected

Use existing transition logs in data/catalog/lineage/ for tests (real data, not mocks).
Use pytest fixtures for PipelineConfig and LineageGraph.
  </action>
  <verify>
    pytest tests/test_lineage_graph.py -v
  </verify>
  <done>
    - All tests pass
    - Tests cover graph building, traversal, and edge cases
    - Tests use real transition log data
  </done>
</task>

</tasks>

<verification>
1. Module structure: `ls src/jobforge/governance/` shows __init__.py, models.py, graph.py
2. Import works: `python -c "from jobforge.governance import LineageGraph"`
3. Graph builds: LineageGraph loads 130+ transition logs into DAG
4. Traversal works: get_upstream("dim_noc", "gold") returns staged/bronze/silver ancestors
5. Tests pass: `pytest tests/test_lineage_graph.py -v` all green
</verification>

<success_criteria>
- LineageGraph class exists in src/jobforge/governance/graph.py
- NetworkX dependency added to pyproject.toml
- Graph builds from existing transition logs (130+ files)
- get_upstream/get_downstream/get_path methods return correct results
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-data-governance-lineage/05-01-SUMMARY.md`
</output>
