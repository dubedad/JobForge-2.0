---
phase: 05-data-governance-lineage
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/jobforge/governance/query.py
  - src/jobforge/governance/__init__.py
  - src/jobforge/cli/commands.py
  - tests/test_lineage_query.py
autonomous: true

must_haves:
  truths:
    - "User can ask 'Where does DIM NOC come from?' and get pipeline path"
    - "User can ask 'What tables feed FACT NOC COPS?' and get upstream dependencies"
    - "Lineage answers include provenance metadata (source files, timestamps)"
    - "CLI provides /lineage command for conversational queries"
  artifacts:
    - path: "src/jobforge/governance/query.py"
      provides: "LineageQueryEngine class"
      exports: ["LineageQueryEngine"]
    - path: "src/jobforge/cli/commands.py"
      provides: "Updated CLI with lineage command"
      contains: "lineage"
    - path: "tests/test_lineage_query.py"
      provides: "Tests for query engine"
      min_lines: 60
  key_links:
    - from: "src/jobforge/governance/query.py"
      to: "src/jobforge/governance/graph.py"
      via: "LineageGraph"
      pattern: "LineageGraph"
    - from: "src/jobforge/cli/commands.py"
      to: "src/jobforge/governance/query.py"
      via: "LineageQueryEngine"
      pattern: "LineageQueryEngine"
---

<objective>
Build LineageQueryEngine with rule-based natural language parsing and CLI integration.

Purpose: Satisfy CONV-01 by enabling users to ask lineage questions like "Where does DIM NOC come from?" and receive pipeline path answers with provenance metadata. Provides conversational interface to the lineage graph.

Output: LineageQueryEngine class with pattern-based query parsing, formatted answers with provenance, and `/lineage` CLI command.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-data-governance-lineage/05-RESEARCH.md

# Plan dependencies (must be complete)
@.planning/phases/05-data-governance-lineage/05-01-SUMMARY.md (LineageGraph)
@.planning/phases/05-data-governance-lineage/05-02-SUMMARY.md (CatalogueGenerator)

# Existing infrastructure
@src/jobforge/cli/commands.py - Existing CLI with /stagegold
@src/jobforge/governance/graph.py - LineageGraph (from 05-01)
@src/jobforge/governance/catalogue.py - CatalogueGenerator (from 05-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LineageQueryEngine with rule-based parsing</name>
  <files>src/jobforge/governance/query.py</files>
  <action>
Create `src/jobforge/governance/query.py` with LineageQueryEngine class:

```python
import re
from typing import Callable
from jobforge.governance.graph import LineageGraph
from jobforge.pipeline.config import PipelineConfig

class LineageQueryEngine:
    """Rule-based natural language to lineage query engine."""

    def __init__(self, graph: LineageGraph):
        self.graph = graph
        self._ensure_graph_built()
        self.patterns: list[tuple[re.Pattern, Callable]] = self._build_patterns()

    def _ensure_graph_built(self):
        """Lazy-build graph if not already built."""
        _ = self.graph.graph  # Triggers lazy load

    def _build_patterns(self) -> list[tuple[re.Pattern, Callable]]:
        """Build pattern -> handler mappings."""
        return [
            # "Where does X come from?"
            (re.compile(r"where does (\w+) come from", re.I),
             self._handle_upstream),
            # "What feeds X?" / "What tables feed X?"
            (re.compile(r"what (?:tables? )?feeds? (\w+)", re.I),
             self._handle_upstream),
            # "What does X feed?" / "What depends on X?"
            (re.compile(r"what (?:does )?(\w+) feed", re.I),
             self._handle_downstream),
            (re.compile(r"what depends on (\w+)", re.I),
             self._handle_downstream),
            # "Show lineage for X" / "Lineage of X"
            (re.compile(r"(?:show )?lineage (?:for |of )?(\w+)", re.I),
             self._handle_full_lineage),
            # "How does X become Y?" / "Path from X to Y"
            (re.compile(r"how does (\w+) become (\w+)", re.I),
             self._handle_path),
            (re.compile(r"path from (\w+) to (\w+)", re.I),
             self._handle_path),
        ]

    def query(self, question: str) -> str:
        """Process natural language question, return human-readable answer."""
        # Try each pattern
        for pattern, handler in self.patterns:
            match = pattern.search(question)
            if match:
                return handler(*match.groups())

        return self._help_message()

    def _handle_upstream(self, table: str) -> str:
        """Format upstream lineage answer with provenance."""

    def _handle_downstream(self, table: str) -> str:
        """Format downstream lineage answer."""

    def _handle_full_lineage(self, table: str) -> str:
        """Show both upstream and downstream."""

    def _handle_path(self, source: str, target: str) -> str:
        """Show transformation path with provenance metadata."""

    def _help_message(self) -> str:
        """Return help for unrecognized queries."""
```

Key implementation details:
- Table name matching: Case-insensitive, handle underscores (dim_noc) and spaces
- Normalize table names: Remove common prefixes (dim_, fact_) for matching
- Try multiple layers: If "dim_noc" not found, try "gold.dim_noc", "silver.dim_noc", etc.
- Include provenance in answers:
  - Source files (from transition logs)
  - Timestamps (from transition logs)
  - Transform names applied
- Format output for CLI readability (use Rich formatting if available, plain text fallback)
  </action>
  <verify>
    python -c "from jobforge.governance.query import LineageQueryEngine; from jobforge.governance.graph import LineageGraph; from jobforge.pipeline.config import PipelineConfig; q = LineageQueryEngine(LineageGraph(PipelineConfig())); print(q.query('Where does dim_noc come from?'))"
  </verify>
  <done>
    - LineageQueryEngine parses natural language patterns
    - query() returns formatted answers with provenance
    - Handles upstream, downstream, path, and full lineage queries
    - Returns helpful message for unrecognized queries
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /lineage CLI command</name>
  <files>
    src/jobforge/cli/commands.py
    src/jobforge/governance/__init__.py
  </files>
  <action>
1. Update `src/jobforge/governance/__init__.py` to export LineageQueryEngine:
```python
from jobforge.governance.graph import LineageGraph
from jobforge.governance.models import LineageNode, LineageEdge
from jobforge.governance.catalogue import CatalogueGenerator, generate_catalogue
from jobforge.governance.query import LineageQueryEngine

__all__ = [
    "LineageGraph",
    "LineageNode",
    "LineageEdge",
    "CatalogueGenerator",
    "generate_catalogue",
    "LineageQueryEngine",
]
```

2. Add lineage command to `src/jobforge/cli/commands.py`:
```python
@app.command()
def lineage(
    question: str = typer.Argument(..., help="Lineage question to answer"),
):
    """
    Answer lineage questions about the WiQ data pipeline.

    Examples:
        jobforge lineage "Where does dim_noc come from?"
        jobforge lineage "What tables feed cops_employment?"
        jobforge lineage "Path from noc_structure to dim_noc"
    """
    from jobforge.governance import LineageGraph, LineageQueryEngine
    from jobforge.pipeline.config import PipelineConfig

    config = PipelineConfig()
    graph = LineageGraph(config)
    engine = LineageQueryEngine(graph)

    answer = engine.query(question)
    console.print(answer)
```

Use Rich console for formatted output (already imported in commands.py for stagegold).
  </action>
  <verify>
    jobforge lineage "Where does dim_noc come from?"
  </verify>
  <done>
    - /lineage command added to CLI
    - Command accepts question as argument
    - Returns formatted lineage answer
    - Works for all supported query types
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for LineageQueryEngine</name>
  <files>tests/test_lineage_query.py</files>
  <action>
Create `tests/test_lineage_query.py` with tests:

1. Test pattern matching:
   - test_where_does_pattern: "Where does X come from?"
   - test_what_feeds_pattern: "What feeds X?"
   - test_what_depends_pattern: "What depends on X?"
   - test_path_pattern: "Path from X to Y"
   - test_how_does_pattern: "How does X become Y?"

2. Test query responses (using real data):
   - test_upstream_query_returns_ancestors: Query dim_noc, verify staged/bronze/silver in answer
   - test_downstream_query_returns_descendants: Query staged file, verify gold in answer
   - test_path_query_returns_chain: Verify layer progression in answer
   - test_full_lineage_shows_both_directions: Verify both upstream and downstream

3. Test provenance in answers:
   - test_answer_includes_source_files: Verify source file names in output
   - test_answer_includes_transforms: Verify transform names in output

4. Test edge cases:
   - test_unknown_table_returns_helpful_message: Graceful handling
   - test_unrecognized_query_returns_help: Help message for garbage input
   - test_case_insensitive_matching: "DIM_NOC" and "dim_noc" both work

Use pytest fixtures for PipelineConfig, LineageGraph, LineageQueryEngine.
  </action>
  <verify>
    pytest tests/test_lineage_query.py -v
  </verify>
  <done>
    - All tests pass
    - Tests cover all query patterns
    - Tests verify provenance in answers
    - Tests handle edge cases gracefully
  </done>
</task>

</tasks>

<verification>
1. Query engine works: `python -c "from jobforge.governance import LineageQueryEngine, LineageGraph; ..."`
2. CLI command works: `jobforge lineage "Where does dim_noc come from?"`
3. Upstream query: Answer shows staged -> bronze -> silver -> gold path
4. Downstream query: Answer shows dependent tables
5. Provenance present: Answers include source files and transforms
6. Tests pass: `pytest tests/test_lineage_query.py -v` all green
7. Success criteria from ROADMAP:
   - "Where does DIM NOC come from?" returns pipeline path: VERIFIED
   - "What tables feed FACT NOC COPS?" returns upstream dependencies: VERIFIED
   - Answers include provenance metadata: VERIFIED
</verification>

<success_criteria>
- LineageQueryEngine parses 5+ query patterns (upstream, downstream, path, full, depends)
- Answers include provenance metadata (source files, transforms, timestamps)
- /lineage CLI command works for all query types
- "Where does DIM NOC come from?" returns: staged -> bronze -> silver -> gold path
- "What tables feed FACT NOC COPS?" returns upstream dependencies
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-data-governance-lineage/05-03-SUMMARY.md`
</output>
