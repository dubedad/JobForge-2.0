---
phase: 10-governance-conversational
plan: 03
type: execute
wave: 2
depends_on: [10-02]
files_modified:
  - orbit/retrievers/duckdb.py
  - orbit/config/adapters/jobforge.yaml
  - orbit/config/intents/wiq_intents.yaml
  - docs/orbit-integration.md
autonomous: false

must_haves:
  truths:
    - "User can ask WiQ data questions through Orbit UI and get accurate responses"
    - "User can ask WiQ metadata questions through Orbit and get lineage information"
    - "Orbit routes data questions to /api/query/data endpoint"
    - "Orbit routes metadata questions to /api/query/metadata endpoint"
  artifacts:
    - path: "orbit/retrievers/duckdb.py"
      provides: "DuckDBRetriever extending Orbit BaseRetriever"
      exports: ["DuckDBRetriever"]
    - path: "orbit/config/adapters/jobforge.yaml"
      provides: "Orbit adapter configuration for JobForge API"
      contains: "type: http"
    - path: "orbit/config/intents/wiq_intents.yaml"
      provides: "Intent templates for WiQ domain queries"
      contains: "occupation_queries"
    - path: "docs/orbit-integration.md"
      provides: "Integration guide for Orbit + JobForge"
  key_links:
    - from: "orbit/config/adapters/jobforge.yaml"
      to: "http://localhost:8000/api"
      via: "HTTP adapter configuration"
      pattern: "base_url.*localhost:8000"
    - from: "orbit/retrievers/duckdb.py"
      to: "data/gold/*.parquet"
      via: "DuckDB parquet queries"
      pattern: "duckdb\\.connect"
---

<objective>
Integrate JobForge with Orbit conversational gateway for production-ready UI and intent routing.

Purpose: Provide users with a polished conversational interface (React UI, CLI, widget) for querying WiQ data and metadata through Orbit's intent-aware routing (GOV-05, GOV-06 user-facing completion).

Output: Orbit configuration files, DuckDBRetriever, intent templates, and integration documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-governance-conversational/10-RESEARCH.md

# Depends on Plan 02 API
@.planning/phases/10-governance-conversational/10-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DuckDBRetriever for Orbit</name>
  <files>
    - orbit/retrievers/__init__.py
    - orbit/retrievers/duckdb.py
  </files>
  <action>
Create DuckDBRetriever that extends Orbit's BaseRetriever pattern for direct parquet queries.

**Note:** This is created in a local `orbit/` directory within JobForge, to be copied to Orbit installation. The retriever follows Orbit's retriever interface.

**orbit/retrievers/duckdb.py:**
```python
"""DuckDB Retriever for Orbit - queries parquet files directly.

This retriever enables Orbit to query DuckDB parquet files using text-to-SQL.
It follows the same pattern as Orbit's built-in SQLiteRetriever.

Usage:
    Copy this file to orbit/server/retrievers/duckdb.py
    Register in orbit/server/retrievers/__init__.py
"""

from pathlib import Path
from typing import Any
import duckdb
import anthropic
from pydantic import BaseModel, Field


class SQLQuery(BaseModel):
    """Structured output for SQL generation."""
    sql: str = Field(description="DuckDB-compatible SELECT query")
    explanation: str = Field(description="Brief explanation")


class DuckDBRetriever:
    """Orbit retriever for DuckDB parquet queries.

    This retriever uses Claude structured outputs to generate SQL from
    natural language, then executes against DuckDB in-memory views.

    Configuration (adapters.yaml):
        implementation: retrievers.duckdb.DuckDBRetriever
        config:
            parquet_path: "data/gold/"
            anthropic_model: "claude-sonnet-4-20250514"
    """

    def __init__(self, config: dict[str, Any]):
        """Initialize the retriever.

        Args:
            config: Retriever configuration from adapters.yaml
        """
        self.parquet_path = Path(config.get("parquet_path", "data/gold"))
        self.model = config.get("anthropic_model", "claude-sonnet-4-20250514")
        self._conn: duckdb.DuckDBPyConnection | None = None
        self._schema_ddl: str | None = None
        self._client: anthropic.Anthropic | None = None

    def initialize(self) -> None:
        """Initialize DuckDB connection and register parquet tables as views."""
        self._conn = duckdb.connect(":memory:")
        self._client = anthropic.Anthropic()

        ddl_parts = []
        for parquet in sorted(self.parquet_path.glob("*.parquet")):
            table_name = parquet.stem
            self._conn.execute(
                f"CREATE VIEW {table_name} AS SELECT * FROM '{parquet}'"
            )
            # Get schema for DDL
            cols = self._conn.execute(f"DESCRIBE {table_name}").fetchall()
            col_defs = [f"  {col[0]} {col[1]}" for col in cols]
            ddl_parts.append(
                f"CREATE TABLE {table_name} (\n" + ",\n".join(col_defs) + "\n);"
            )

        self._schema_ddl = "\n\n".join(ddl_parts)

    def retrieve(self, query: str, collection_name: str = "") -> list[dict]:
        """Generate SQL from query and execute.

        Args:
            query: Natural language question
            collection_name: Unused (for interface compatibility)

        Returns:
            List of result dictionaries
        """
        if self._conn is None:
            self.initialize()

        try:
            # Generate SQL using Claude
            response = self._client.messages.create(
                model=self.model,
                max_tokens=1024,
                system=self._get_system_prompt(),
                messages=[{
                    "role": "user",
                    "content": f"Schema:\n{self._schema_ddl}\n\nQuestion: {query}"
                }],
                extra_headers={"anthropic-beta": "structured-outputs-2025-11-13"},
                response_format={
                    "type": "json_schema",
                    "json_schema": {
                        "name": "sql_query",
                        "schema": SQLQuery.model_json_schema(),
                    }
                }
            )

            sql_result = SQLQuery.model_validate_json(response.content[0].text)

            # Execute and return results
            df = self._conn.execute(sql_result.sql).fetchdf()
            return df.to_dict(orient="records")

        except Exception as e:
            return [{"error": str(e), "query": query}]

    def _get_system_prompt(self) -> str:
        return """You are a SQL expert for the WiQ (Workforce Intelligence) database.
Generate DuckDB-compatible SELECT queries only. Never modify data.
The database contains Canadian occupational data:
- dim_noc: National Occupational Classification
- cops_*: Occupational projections
- oasis_*: Skills, abilities, knowledge
- element_*: NOC element data"""

    def close(self) -> None:
        """Close DuckDB connection."""
        if self._conn:
            self._conn.close()
            self._conn = None
```

**orbit/retrievers/__init__.py:**
```python
"""Custom retrievers for Orbit integration."""
from orbit.retrievers.duckdb import DuckDBRetriever

__all__ = ["DuckDBRetriever"]
```

This follows the Orbit retriever pattern documented in their adapters documentation.
  </action>
  <verify>
```bash
# Verify syntax
python -m py_compile orbit/retrievers/duckdb.py

# Unit test (mock anthropic)
python -c "
from orbit.retrievers.duckdb import DuckDBRetriever, SQLQuery
# Test SQLQuery model
q = SQLQuery(sql='SELECT 1', explanation='test')
assert q.sql == 'SELECT 1'
print('DuckDBRetriever module OK')
"
```
  </verify>
  <done>
DuckDBRetriever created following Orbit's BaseRetriever pattern. Uses Claude structured outputs for SQL generation, DuckDB for execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Orbit Configuration Files</name>
  <files>
    - orbit/config/adapters/jobforge.yaml
    - orbit/config/intents/wiq_intents.yaml
  </files>
  <action>
Create Orbit adapter and intent configuration files for JobForge integration.

**orbit/config/adapters/jobforge.yaml:**
```yaml
# JobForge adapter configuration for Orbit
# Copy to: orbit/config/adapters/jobforge.yaml

name: jobforge-wiq
description: "Workforce Intelligence Query interface for Canadian occupational data"
enabled: true
type: http

# HTTP adapter routes questions to JobForge API
http:
  base_url: "http://localhost:8000"
  endpoints:
    data:
      path: "/api/query/data"
      method: POST
      body:
        question: "{{query}}"
    metadata:
      path: "/api/query/metadata"
      method: POST
      body:
        question: "{{query}}"
    compliance:
      path: "/api/compliance/{{framework}}"
      method: GET

# Intent routing rules
intents:
  - name: data_query
    description: "Questions about WiQ data (counts, aggregations, lookups)"
    endpoint: data
    patterns:
      - "how many"
      - "count of"
      - "list all"
      - "what is the"
      - "show me"
      - "find"
    examples:
      - "How many software developers are projected for 2025?"
      - "List all NOC unit groups in TEER 1"
      - "What are the main duties for 21232?"

  - name: metadata_query
    description: "Questions about data lineage, provenance, and structure"
    endpoint: metadata
    patterns:
      - "where does"
      - "come from"
      - "lineage"
      - "what feeds"
      - "depends on"
      - "describe table"
      - "what columns"
    examples:
      - "Where does dim_noc come from?"
      - "Show lineage for cops_employment"
      - "What columns are in element_labels?"

  - name: compliance_query
    description: "Questions about governance compliance"
    endpoint: compliance
    patterns:
      - "dadm compliance"
      - "dama compliance"
      - "classification compliance"
      - "is wiq compliant"
    examples:
      - "Show DADM compliance status"
      - "Is WiQ DAMA compliant?"

# LLM configuration for intent classification
llm:
  provider: anthropic
  model: claude-sonnet-4-20250514
  temperature: 0
```

**orbit/config/intents/wiq_intents.yaml:**
```yaml
# WiQ domain-specific intent templates
# These help Orbit classify user questions correctly

domain: workforce_intelligence
description: "Canadian Occupational Classification and Workforce Projections"

intent_categories:
  occupation_queries:
    description: "Questions about occupations, NOC codes, job titles"
    keywords:
      - NOC
      - occupation
      - job title
      - unit group
      - TEER
      - broad category
    sample_questions:
      - "What occupations are in broad category 2?"
      - "Show all TEER 1 unit groups"
      - "What is the class title for NOC 21232?"

  forecast_queries:
    description: "Questions about COPS employment projections"
    keywords:
      - projection
      - forecast
      - employment growth
      - retirement
      - immigration
      - school leavers
    sample_questions:
      - "What is the projected employment for software developers?"
      - "Show retirement rates for healthcare occupations"
      - "Immigration numbers for TEER 2 occupations"

  attribute_queries:
    description: "Questions about occupational attributes (skills, abilities)"
    keywords:
      - skill
      - ability
      - knowledge
      - work activity
      - work context
    sample_questions:
      - "What skills are needed for 21232?"
      - "List abilities for software developers"
      - "What work activities are common in TEER 1?"

  lineage_queries:
    description: "Questions about data sources and transformations"
    keywords:
      - source
      - lineage
      - come from
      - transform
      - upstream
      - downstream
    sample_questions:
      - "Where does dim_noc data come from?"
      - "What tables feed cops_employment?"
      - "Show the transformation path for dim_occupations"

  compliance_queries:
    description: "Questions about governance framework compliance"
    keywords:
      - DADM
      - DAMA
      - compliance
      - governance
      - classification policy
    sample_questions:
      - "Is WiQ DADM compliant?"
      - "Show DAMA DMBOK compliance"
      - "Classification policy adherence status"
```
  </action>
  <verify>
```bash
# Validate YAML syntax
python -c "
import yaml
from pathlib import Path

for f in ['orbit/config/adapters/jobforge.yaml', 'orbit/config/intents/wiq_intents.yaml']:
    data = yaml.safe_load(Path(f).read_text())
    print(f'{f}: valid YAML')
    if 'name' in data:
        print(f'  Adapter: {data[\"name\"]}')
    if 'domain' in data:
        print(f'  Domain: {data[\"domain\"]}')
"
```
YAML files parse without errors.
  </verify>
  <done>
Orbit adapter configuration routes data/metadata/compliance queries to JobForge API. Intent templates define WiQ domain vocabulary for accurate classification.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Orbit integration files ready for deployment:
- DuckDBRetriever for direct parquet queries
- Adapter configuration pointing to JobForge API
- Intent templates for WiQ domain
  </what-built>
  <how-to-verify>
1. **Start JobForge API server:**
   ```bash
   jobforge api
   ```
   Verify it starts on http://localhost:8000

2. **Test API endpoints directly:**
   ```bash
   # Metadata query (no API key needed)
   curl -X POST http://localhost:8000/api/query/metadata \
        -H "Content-Type: application/json" \
        -d '{"question": "where does dim_noc come from?"}'

   # Data query (needs ANTHROPIC_API_KEY)
   curl -X POST http://localhost:8000/api/query/data \
        -H "Content-Type: application/json" \
        -d '{"question": "how many unit groups in dim_noc?"}'

   # Compliance endpoint
   curl http://localhost:8000/api/compliance/dadm | head -100
   ```

3. **Optional: Deploy Orbit** (if user wants full UI):
   ```bash
   # Clone Orbit
   git clone https://github.com/schmitech/orbit.git
   cd orbit

   # Copy JobForge config files
   cp ../JobForge\ 2.0/orbit/retrievers/duckdb.py server/retrievers/
   cp ../JobForge\ 2.0/orbit/config/adapters/jobforge.yaml config/adapters/
   cp ../JobForge\ 2.0/orbit/config/intents/wiq_intents.yaml config/intents/

   # Start Orbit (requires Docker or Node.js)
   docker-compose up -d
   # OR
   ./bin/orbit.sh start

   # Open http://localhost:3000 and ask:
   # "How many tables are in WiQ?"
   # "Where does dim_noc come from?"
   ```

4. **Verify end-to-end flow:**
   - User asks question in Orbit UI
   - Orbit classifies intent (data vs metadata)
   - Orbit routes to correct JobForge endpoint
   - JobForge returns answer
   - Orbit displays formatted response
  </how-to-verify>
  <resume-signal>Type "approved" if JobForge API works and integration files are ready. Type "skip-orbit" if you want to defer Orbit deployment. Describe any issues encountered.</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Create Integration Documentation</name>
  <files>
    - docs/orbit-integration.md
  </files>
  <action>
Create integration guide documenting Orbit setup with JobForge.

**docs/orbit-integration.md:**
```markdown
# Orbit Integration Guide

This guide explains how to integrate JobForge with [Orbit](https://github.com/schmitech/orbit) for a production-ready conversational interface.

## Overview

JobForge provides HTTP APIs for querying WiQ data and metadata. Orbit provides:
- Intent-aware routing (data vs metadata questions)
- Multiple UIs (React web app, CLI, embeddable widget)
- Multi-LLM support (can switch providers)
- Conversation history and context

## Architecture

```
User Question
     │
     ▼
┌─────────────────┐
│  Orbit Gateway  │ ◄── Intent Classification
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌───────┐ ┌────────┐
│ Data  │ │Metadata│
│ Query │ │ Query  │
└───┬───┘ └───┬────┘
    │         │
    ▼         ▼
┌─────────────────┐
│  JobForge API   │
│ localhost:8000  │
└─────────────────┘
```

## Prerequisites

1. JobForge installed with gold tables:
   ```bash
   pip install -e .
   jobforge run  # Generate gold tables
   ```

2. Anthropic API key for data queries:
   ```bash
   export ANTHROPIC_API_KEY=sk-...
   ```

3. Docker (for Orbit) or Node.js 18+

## Quick Start

### 1. Start JobForge API

```bash
jobforge api
# API running on http://localhost:8000
# Docs at http://localhost:8000/docs
```

### 2. Install Orbit

```bash
git clone https://github.com/schmitech/orbit.git
cd orbit
```

### 3. Copy JobForge Configuration

```bash
# From JobForge 2.0 directory
cp orbit/retrievers/duckdb.py ../orbit/server/retrievers/
cp orbit/config/adapters/jobforge.yaml ../orbit/config/adapters/
cp orbit/config/intents/wiq_intents.yaml ../orbit/config/intents/
```

### 4. Start Orbit

With Docker:
```bash
docker-compose up -d
```

Or locally:
```bash
npm install
npm run dev
```

### 5. Access Orbit UI

Open http://localhost:3000 and try:
- "How many unit groups are in WiQ?"
- "Where does dim_noc come from?"
- "Show DADM compliance status"

## API Endpoints

JobForge exposes these endpoints for Orbit:

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/api/query/data` | POST | Natural language data queries |
| `/api/query/metadata` | POST | Lineage and provenance queries |
| `/api/compliance/{framework}` | GET | Compliance traceability logs |
| `/api/health` | GET | Health check |

### Data Query Example

```bash
curl -X POST http://localhost:8000/api/query/data \
     -H "Content-Type: application/json" \
     -d '{"question": "how many TEER 1 occupations?"}'
```

Response:
```json
{
  "question": "how many TEER 1 occupations?",
  "sql": "SELECT COUNT(*) FROM dim_noc WHERE teer_level = '1'",
  "explanation": "Counts occupations with TEER level 1",
  "results": [{"count": 87}],
  "row_count": 1
}
```

### Metadata Query Example

```bash
curl -X POST http://localhost:8000/api/query/metadata \
     -H "Content-Type: application/json" \
     -d '{"question": "where does dim_noc come from?"}'
```

Response:
```json
{
  "question": "where does dim_noc come from?",
  "answer": "Upstream lineage for 'dim_noc' (Gold):\n\nStaged (raw):\n  - noc_structure\n..."
}
```

## Intent Routing

Orbit uses pattern matching and LLM classification to route questions:

| Pattern | Intent | Endpoint |
|---------|--------|----------|
| "how many", "count", "list all" | data_query | /api/query/data |
| "where does", "lineage", "come from" | metadata_query | /api/query/metadata |
| "DADM compliance", "DAMA compliance" | compliance_query | /api/compliance/{fw} |

## Troubleshooting

### "ANTHROPIC_API_KEY not set"
Data queries require Claude API. Set the environment variable:
```bash
export ANTHROPIC_API_KEY=sk-ant-...
```

### "Table not found"
Ensure gold tables exist:
```bash
ls data/gold/*.parquet
# Should show 24 parquet files
```

### Orbit can't connect to JobForge
Check JobForge API is running:
```bash
curl http://localhost:8000/api/health
# {"status": "ok"}
```

## Standalone Usage (Without Orbit)

JobForge API works without Orbit for programmatic access:

```python
import httpx

# Metadata query
response = httpx.post(
    "http://localhost:8000/api/query/metadata",
    json={"question": "list all tables"}
)
print(response.json()["answer"])

# Data query
response = httpx.post(
    "http://localhost:8000/api/query/data",
    json={"question": "count unit groups by TEER"}
)
print(response.json()["results"])
```
```
  </action>
  <verify>
```bash
# Verify markdown renders
python -c "
from pathlib import Path
content = Path('docs/orbit-integration.md').read_text()
assert '## Quick Start' in content
assert 'jobforge api' in content
assert '/api/query/data' in content
print('Documentation complete')
"
```
  </verify>
  <done>
Integration documentation created with architecture diagram, quick start guide, API examples, and troubleshooting section.
  </done>
</task>

</tasks>

<verification>
**Phase-level verification:**

1. DuckDBRetriever compiles and follows Orbit pattern:
```bash
python -m py_compile orbit/retrievers/duckdb.py
```

2. Configuration files are valid YAML:
```bash
python -c "import yaml; yaml.safe_load(open('orbit/config/adapters/jobforge.yaml'))"
```

3. JobForge API endpoints work (from Plan 02):
```bash
jobforge api &
sleep 3
curl http://localhost:8000/api/health
curl -X POST http://localhost:8000/api/query/metadata \
     -H "Content-Type: application/json" \
     -d '{"question": "how many tables?"}'
```

4. Documentation covers all integration steps
</verification>

<success_criteria>
- DuckDBRetriever created following Orbit retriever interface
- Adapter configuration routes to JobForge API endpoints
- Intent templates define WiQ domain vocabulary
- Human verifies API works via curl
- Integration documentation complete
- Ready for Orbit deployment (user's choice to deploy)
</success_criteria>

<output>
After completion, create `.planning/phases/10-governance-conversational/10-03-SUMMARY.md`
</output>
