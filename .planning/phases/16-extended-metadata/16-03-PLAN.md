---
phase: 16-extended-metadata
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jobforge/external/tbs/represented_pay_scraper.py
  - src/jobforge/external/tbs/collective_agreement_scraper.py
  - src/jobforge/ingestion/og_represented_pay.py
  - data/tbs/og_represented_pay_rates.json
  - data/tbs/collective_agreements.json
  - data/gold/dim_collective_agreement.parquet
  - data/catalog/tables/dim_collective_agreement.json
  - data/catalog/tables/fact_og_pay_rates.json
  - tests/external/tbs/test_represented_pay_scraper.py
  - tests/external/tbs/test_collective_agreement_scraper.py
  - tests/ingestion/test_og_represented_pay.py
autonomous: true

must_haves:
  truths:
    - "User can query both excluded AND represented pay rates"
    - "User can query historical pay rates (not just current)"
    - "User can query collective agreement metadata (name, expiry, bargaining agent)"
    - "Pay rates link to collective agreements via FK"
    - "EX salary ranges included"
  artifacts:
    - path: "src/jobforge/external/tbs/represented_pay_scraper.py"
      provides: "Represented/unionized pay rates scraper"
      exports: ["scrape_represented_pay_rates", "RepresentedPayRate"]
    - path: "src/jobforge/external/tbs/collective_agreement_scraper.py"
      provides: "Collective agreement metadata scraper"
      exports: ["scrape_collective_agreements", "CollectiveAgreement"]
    - path: "data/gold/dim_collective_agreement.parquet"
      provides: "Collective agreements dimension table"
      min_rows: 30
    - path: "data/gold/fact_og_pay_rates.parquet"
      provides: "Extended pay rates fact table with represented rates"
      min_rows: 1000
  key_links:
    - from: "data/gold/fact_og_pay_rates.parquet"
      to: "data/gold/dim_collective_agreement.parquet"
      via: "FK collective_agreement_id"
      pattern: "collective_agreement_id"
---

<objective>
Extend pay rates scraping to include represented/unionized rates with collective agreement metadata.

Purpose: Enable comprehensive pay intelligence queries covering both excluded employees (Phase 14-04) and unionized workers. Per CONTEXT.md: "Both excluded employees AND represented (unionized) rates" and "All available historical rates."
Output: Extended fact_og_pay_rates with represented rates, new dim_collective_agreement dimension.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-extended-metadata/16-CONTEXT.md
@.planning/phases/16-extended-metadata/16-RESEARCH.md
@src/jobforge/external/tbs/pay_rates_scraper.py
@src/jobforge/ingestion/og_pay_rates.py
@.planning/phases/14-og-core/14-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create collective agreement scraper</name>
  <files>
    src/jobforge/external/tbs/collective_agreement_scraper.py
    data/tbs/collective_agreements.json
    tests/external/tbs/test_collective_agreement_scraper.py
  </files>
  <action>
Create `src/jobforge/external/tbs/collective_agreement_scraper.py`:

1. `CollectiveAgreement` Pydantic model (per CONTEXT.md):
   ```python
   class CollectiveAgreement(BaseModel):
       agreement_id: str  # Generated UUID or slugified name
       agreement_name: str  # e.g., "EC Group Collective Agreement"
       og_code: str  # FK to dim_og
       bargaining_agent: str  # e.g., "Canadian Association of Professional Employees"
       employer: str = "Treasury Board of Canada Secretariat"

       effective_date: str  # YYYY-MM-DD
       expiry_date: str | None = None  # YYYY-MM-DD or null if evergreen

       source_url: str
       scraped_at: str
   ```

2. `scrape_collective_agreements(delay: float = 1.5) -> list[CollectiveAgreement]`:
   - Scrape from: https://www.canada.ca/en/treasury-board-secretariat/topics/pay/collective-agreements.html
   - Extract agreement metadata (not full text per RESEARCH.md Open Question 2)
   - Follow links to individual agreement pages for dates
   - Use 1.5s delay between requests

3. `scrape_all_collective_agreements(output_dir: Path) -> Path`:
   - Orchestrate scraping, save to data/tbs/collective_agreements.json

Create tests in `tests/external/tbs/test_collective_agreement_scraper.py`:
- Test CollectiveAgreement model validation
- Test date parsing (effective_date, expiry_date)
- Test bargaining_agent extraction
- Test scraper handles missing dates gracefully
  </action>
  <verify>
Run: `pytest tests/external/tbs/test_collective_agreement_scraper.py -v`
Tests pass.
Check scraped data: `python -c "import json; data = json.load(open('data/tbs/collective_agreements.json')); print(f'Agreements: {len(data)}')"` (if scraping ran)
  </verify>
  <done>
Collective agreement scraper extracts metadata (name, dates, bargaining agent) from TBS. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create represented pay rates scraper</name>
  <files>
    src/jobforge/external/tbs/represented_pay_scraper.py
    data/tbs/og_represented_pay_rates.json
    tests/external/tbs/test_represented_pay_scraper.py
  </files>
  <action>
Create `src/jobforge/external/tbs/represented_pay_scraper.py`:

1. `RepresentedPayRate` Pydantic model (extends existing PayRateRow pattern):
   ```python
   class RepresentedPayRate(BaseModel):
       og_code: str
       og_subgroup_code: str
       classification_level: str  # e.g., "EC-04"
       step: int

       annual_rate: Decimal | None = None
       hourly_rate: Decimal | None = None
       effective_date: str | None = None

       is_represented: bool = True
       collective_agreement_id: str | None = None  # FK to dim_collective_agreement

       # Pay progression type (CONTEXT.md)
       pay_progression_type: str = "step"  # 'step', 'performance', 'hybrid'

       source_url: str
       scraped_at: str
   ```

2. `scrape_represented_pay_rates(og_code: str, url: str) -> list[RepresentedPayRate]`:
   - Follow pattern from existing pay_rates_scraper.py
   - Handle same dual table formats (steps-as-columns, dates-as-columns)
   - Set is_represented=True and link to collective_agreement_id
   - Include EX salary ranges from executive compensation pages

3. `scrape_all_represented_pay_rates(output_dir: Path) -> Path`:
   - Discover represented pay rate pages from collective agreements index
   - Scrape all historical rates (not just current per CONTEXT.md)
   - Check for regional differentials (log if not found per RESEARCH.md Open Question 5)
   - Save to data/tbs/og_represented_pay_rates.json

Create tests in `tests/external/tbs/test_represented_pay_scraper.py`:
- Test RepresentedPayRate model validation
- Test pay_progression_type detection
- Test collective_agreement_id linking
- Test historical date range coverage
  </action>
  <verify>
Run: `pytest tests/external/tbs/test_represented_pay_scraper.py -v`
Tests pass.
Check scraped data: `python -c "import json; data = json.load(open('data/tbs/og_represented_pay_rates.json')); print(f'Rows: {len(data)}')"` (if scraping ran)
  </verify>
  <done>
Represented pay rates scraper extracts unionized rates with collective agreement links. Historical rates included. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend fact_og_pay_rates with represented rates and create dim_collective_agreement</name>
  <files>
    src/jobforge/ingestion/og_represented_pay.py
    data/gold/dim_collective_agreement.parquet
    data/gold/fact_og_pay_rates.parquet
    data/catalog/tables/dim_collective_agreement.json
    data/catalog/tables/fact_og_pay_rates.json
    tests/ingestion/test_og_represented_pay.py
  </files>
  <action>
**PREREQUISITE CHECK:** Before any implementation, verify Phase 14-04 output exists:
```python
from pathlib import Path
existing_pay_rates = Path("data/gold/fact_og_pay_rates.parquet")
if not existing_pay_rates.exists():
    raise FileNotFoundError(
        "Phase 14-04 output missing: data/gold/fact_og_pay_rates.parquet must exist before extending. "
        "Run Phase 14-04 first to create excluded pay rates."
    )
```
This plan extends the fact table created in Phase 14-04. If the file does not exist, Phase 14 must be completed first.

Create `src/jobforge/ingestion/og_represented_pay.py`:

1. `ingest_dim_collective_agreement()`:
   - Load from data/tbs/collective_agreements.json
   - Bronze: Parse JSON, generate stable agreement_id
   - Silver: Normalize og_codes, validate dates
   - Gold: Write data/gold/dim_collective_agreement.parquet
   - Schema: agreement_id, agreement_name, og_code, bargaining_agent, employer, effective_date, expiry_date, provenance fields

2. `extend_fact_og_pay_rates()`:
   - **First verify existing fact_og_pay_rates.parquet exists** (from Phase 14-04)
   - Load existing fact_og_pay_rates.parquet (excluded rates from 14-04)
   - Load new represented rates from data/tbs/og_represented_pay_rates.json
   - Merge both sources with is_represented flag
   - Add collective_agreement_id FK column
   - Add pay_progression_type column
   - Dedupe by natural key (og_subgroup_code, classification_level, step, effective_date, is_represented)
   - Write extended fact_og_pay_rates.parquet

3. Updated fact_og_pay_rates schema:
   ```python
   columns = [
       # Existing columns from 14-04
       "og_code",
       "og_subgroup_code",
       "classification_level",
       "step",
       "annual_rate",
       "hourly_rate",
       "effective_date",
       # New columns
       "is_represented",           # True for unionized, False for excluded
       "collective_agreement_id",  # FK to dim_collective_agreement (nullable)
       "pay_progression_type",     # 'step', 'performance', 'hybrid'
       # Provenance
       "_source_url",
       "_scraped_at",
       "_ingested_at",
       "_batch_id",
       "_layer",
   ]
   ```

Create `data/catalog/tables/dim_collective_agreement.json`:
- Column descriptions for all fields
- Relationship to dim_og via og_code

Update `data/catalog/tables/fact_og_pay_rates.json`:
- Add new column descriptions (is_represented, collective_agreement_id, pay_progression_type)
- Add relationship to dim_collective_agreement

Create tests in `tests/ingestion/test_og_represented_pay.py`:
- Test collective agreement ingestion
- Test pay rates extension preserves excluded rates
- Test is_represented flag correctly set
- Test FK to dim_collective_agreement
- Test raises FileNotFoundError if Phase 14-04 output missing
  </action>
  <verify>
First verify prerequisite: `python -c "from pathlib import Path; assert Path('data/gold/fact_og_pay_rates.parquet').exists(), 'Phase 14-04 must complete first'"`
Run: `pytest tests/ingestion/test_og_represented_pay.py -v`
Tests pass.
Check: `python -c "import polars as pl; df = pl.read_parquet('data/gold/fact_og_pay_rates.parquet'); print(f'Rows: {len(df)}, Represented: {df.filter(pl.col(\"is_represented\")).height}')"`
Output shows more rows than before (991 excluded + represented), with some marked is_represented=True.
Check: `python -c "import polars as pl; df = pl.read_parquet('data/gold/dim_collective_agreement.parquet'); print(f'Agreements: {len(df)}')"` (30+ expected)
  </verify>
  <done>
dim_collective_agreement.parquet created with collective agreement metadata. fact_og_pay_rates.parquet extended with represented rates, is_represented flag, and FK to collective agreements. Tests pass.
  </done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `pytest tests/external/tbs/test_collective_agreement_scraper.py -v` - Pass
2. `pytest tests/external/tbs/test_represented_pay_scraper.py -v` - Pass
3. `pytest tests/ingestion/test_og_represented_pay.py -v` - Pass
4. Collective agreements JSON and parquet exist
5. fact_og_pay_rates.parquet has is_represented and collective_agreement_id columns
6. Both excluded (is_represented=False) and represented (is_represented=True) rates present
</verification>

<success_criteria>
- dim_collective_agreement.parquet with 30+ collective agreements
- fact_og_pay_rates.parquet extended with represented rates (row count > 991)
- is_represented flag distinguishes excluded vs unionized rates
- collective_agreement_id FK links pay rates to agreements
- Historical rates included (multiple effective_dates per classification)
- Catalog metadata updated for both tables
- All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/16-extended-metadata/16-03-SUMMARY.md`
</output>
