---
phase: 15-caf-core
plan: 04
type: execute
wave: 4
depends_on: ["15-03"]
files_modified:
  - src/jobforge/external/caf/matchers.py
  - src/jobforge/ingestion/caf.py
  - data/gold/bridge_caf_noc.parquet
  - data/reference/caf_noc_mappings.json
  - data/catalog/tables/bridge_caf_noc.json
  - tests/external/test_caf_matchers.py
autonomous: true

must_haves:
  truths:
    - "User can find NOC codes associated with any CAF occupation"
    - "All matches have confidence scores with full audit trail"
    - "Automated matches flagged separately from human-verified"
    - "Bridge table enables CAF-to-civilian career pathway queries"
  artifacts:
    - path: "src/jobforge/external/caf/matchers.py"
      provides: "Fuzzy matching to NOC using rapidfuzz"
      exports: ["match_caf_to_noc", "CAFNOCMatcher"]
    - path: "data/gold/bridge_caf_noc.parquet"
      provides: "CAF to NOC bridge table with confidence scores"
    - path: "data/reference/caf_noc_mappings.json"
      provides: "Human-reviewable mapping file for verification"
  key_links:
    - from: "data/gold/bridge_caf_noc.parquet"
      to: "data/gold/dim_caf_occupation.parquet"
      via: "caf_occupation_id foreign key"
      pattern: "caf_occupation_id"
    - from: "data/gold/bridge_caf_noc.parquet"
      to: "data/gold/dim_noc.parquet"
      via: "noc_unit_group_id foreign key"
      pattern: "noc_unit_group_id"
---

<objective>
Create CAF-to-NOC bridge table with fuzzy matching and confidence scoring.

Purpose: Enable users to find civilian NOC equivalents for CAF occupations. This is critical for veteran transition planning - mapping military careers to civilian job classifications.

Output: bridge_caf_noc.parquet with confidence-scored matches, caf_noc_mappings.json for human verification, matcher module.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-caf-core/15-CONTEXT.md
@.planning/phases/15-caf-core/15-RESEARCH.md

# Prior plan output
@.planning/phases/15-caf-core/15-03-SUMMARY.md

# Existing patterns
@src/jobforge/imputation/models.py
@src/jobforge/external/onet/adapter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CAF-NOC matcher module</name>
  <files>
    src/jobforge/external/caf/matchers.py
  </files>
  <action>
Create `src/jobforge/external/caf/matchers.py` following RESEARCH.md patterns:

```python
"""Fuzzy matching between CAF occupations and NOC codes.

Per CONTEXT.md:
- Hybrid approach: automated fuzzy matching suggests candidates, human verifies
- All matches returned regardless of confidence (user filters)
- Full audit trail: matching factors, intermediate scores, algorithm, verification status
"""
from datetime import datetime, timezone
from typing import Literal
from pathlib import Path
import json

import polars as pl
import structlog
from pydantic import BaseModel, Field
from rapidfuzz import fuzz, process

logger = structlog.get_logger(__name__)


def utc_now() -> datetime:
    """Get current UTC timestamp."""
    return datetime.now(timezone.utc)


class CAFNOCMapping(BaseModel):
    """Single CAF-to-NOC mapping with confidence and audit trail.

    Per CONTEXT.md: Full audit trail with matching factors, scores, algorithm, verification.
    """
    # Keys
    caf_occupation_id: str = Field(description="FK to dim_caf_occupation")
    noc_unit_group_id: str = Field(description="FK to dim_noc (5-digit NOC code)")

    # Confidence
    confidence_score: float = Field(ge=0.0, le=1.0, description="Overall match confidence")

    # Audit trail
    match_method: Literal["automated_fuzzy", "human_verified", "human_rejected"] = Field(
        description="How this match was determined"
    )
    algorithm_version: str = Field(description="Algorithm used, e.g., 'rapidfuzz-3.0-token_sort_ratio'")
    fuzzy_score: float | None = Field(default=None, description="Raw rapidfuzz score (0-100) if automated")
    matched_caf_text: str = Field(description="CAF text that was matched (title or related civilian)")
    matched_noc_text: str = Field(description="NOC text that was matched (class_title)")
    matching_factors: list[str] = Field(default_factory=list, description="What contributed to the score")
    rationale: str = Field(description="Human-readable explanation")

    # Verification
    verified_by: str | None = Field(default=None, description="'human' if reviewed, else None")
    verified_at: datetime | None = Field(default=None)

    # Provenance
    created_at: datetime = Field(default_factory=utc_now)


class CAFNOCMatcher:
    """Matches CAF occupations to NOC codes using fuzzy matching.

    Per RESEARCH.md: Use rapidfuzz token_sort_ratio (ignores word order).
    """

    ALGORITHM_VERSION = "rapidfuzz-3.0-token_sort_ratio"

    def __init__(self, noc_df: pl.DataFrame | None = None):
        """Initialize matcher with NOC data.

        Args:
            noc_df: DataFrame with dim_noc data. If None, loads from parquet.
        """
        if noc_df is None:
            noc_path = Path("data/gold/dim_noc.parquet")
            if not noc_path.exists():
                raise FileNotFoundError(f"dim_noc.parquet not found at {noc_path}")
            noc_df = pl.read_parquet(noc_path)

        self.noc_df = noc_df
        self.noc_titles = noc_df.select(["unit_group_id", "class_title"]).to_dicts()
        self.noc_title_list = [r["class_title"] for r in self.noc_titles]
        self.noc_id_map = {r["class_title"]: r["unit_group_id"] for r in self.noc_titles}

    def _fuzzy_to_confidence(self, fuzzy_score: float) -> float:
        """Convert rapidfuzz score (0-100) to confidence (0.0-1.0).

        Per RESEARCH.md mapping:
        - 100 -> 1.0
        - 90 -> 0.85
        - 80 -> 0.70
        - 70 -> 0.55
        - Below 70 is low confidence
        """
        if fuzzy_score >= 90:
            return 0.85 + (fuzzy_score - 90) * 0.015  # 90-100 -> 0.85-1.0
        elif fuzzy_score >= 80:
            return 0.70 + (fuzzy_score - 80) * 0.015  # 80-90 -> 0.70-0.85
        elif fuzzy_score >= 70:
            return 0.55 + (fuzzy_score - 70) * 0.015  # 70-80 -> 0.55-0.70
        else:
            return fuzzy_score / 100.0 * 0.55  # <70 -> <0.55

    def match_single(
        self,
        caf_occupation_id: str,
        caf_title: str,
        related_civilian: list[str] | None = None,
        threshold: float = 50.0,
        limit: int = 5,
    ) -> list[CAFNOCMapping]:
        """Match single CAF occupation to NOC codes.

        Strategy:
        1. Match CAF title directly against NOC titles
        2. Match related_civilian_occupations against NOC titles
        3. Return union of matches, preferring related_civilian matches (higher confidence)

        Args:
            caf_occupation_id: CAF occupation ID
            caf_title: CAF occupation title (EN)
            related_civilian: List of related civilian occupation titles from forces.ca
            threshold: Minimum fuzzy score (0-100) to include
            limit: Maximum matches per source text

        Returns:
            List of CAFNOCMapping objects sorted by confidence descending.
        """
        mappings = []
        seen_noc_ids = set()

        # Strategy 1: Match from related_civilian_occupations (higher confidence)
        if related_civilian:
            for civ_occ in related_civilian:
                matches = process.extract(
                    civ_occ,
                    self.noc_title_list,
                    scorer=fuzz.token_sort_ratio,
                    score_cutoff=threshold,
                    limit=limit,
                )
                for match_text, score, _ in matches:
                    noc_id = self.noc_id_map.get(match_text)
                    if noc_id and noc_id not in seen_noc_ids:
                        seen_noc_ids.add(noc_id)
                        mappings.append(CAFNOCMapping(
                            caf_occupation_id=caf_occupation_id,
                            noc_unit_group_id=noc_id,
                            confidence_score=self._fuzzy_to_confidence(score),
                            match_method="automated_fuzzy",
                            algorithm_version=self.ALGORITHM_VERSION,
                            fuzzy_score=score,
                            matched_caf_text=civ_occ,
                            matched_noc_text=match_text,
                            matching_factors=[
                                "related_civilian_match",
                                f"fuzzy_score={score:.1f}",
                            ],
                            rationale=f"Matched CAF related civilian occupation '{civ_occ}' to NOC '{match_text}' with {score:.1f}% fuzzy similarity",
                        ))

        # Strategy 2: Match from CAF title directly (lower confidence boost)
        title_matches = process.extract(
            caf_title,
            self.noc_title_list,
            scorer=fuzz.token_sort_ratio,
            score_cutoff=threshold,
            limit=limit,
        )
        for match_text, score, _ in title_matches:
            noc_id = self.noc_id_map.get(match_text)
            if noc_id and noc_id not in seen_noc_ids:
                seen_noc_ids.add(noc_id)
                # Slightly lower confidence for title-only matches
                conf = self._fuzzy_to_confidence(score) * 0.9
                mappings.append(CAFNOCMapping(
                    caf_occupation_id=caf_occupation_id,
                    noc_unit_group_id=noc_id,
                    confidence_score=conf,
                    match_method="automated_fuzzy",
                    algorithm_version=self.ALGORITHM_VERSION,
                    fuzzy_score=score,
                    matched_caf_text=caf_title,
                    matched_noc_text=match_text,
                    matching_factors=[
                        "title_direct_match",
                        f"fuzzy_score={score:.1f}",
                        "confidence_adjusted_0.9x",
                    ],
                    rationale=f"Matched CAF title '{caf_title}' to NOC '{match_text}' with {score:.1f}% fuzzy similarity (title match, 0.9x confidence)",
                ))

        # Sort by confidence descending
        mappings.sort(key=lambda m: m.confidence_score, reverse=True)
        return mappings

    def match_all(
        self,
        caf_df: pl.DataFrame,
        threshold: float = 50.0,
        limit_per_occupation: int = 5,
    ) -> list[CAFNOCMapping]:
        """Match all CAF occupations to NOC codes.

        Args:
            caf_df: DataFrame with dim_caf_occupation data
            threshold: Minimum fuzzy score (0-100)
            limit_per_occupation: Max matches per CAF occupation

        Returns:
            List of all CAFNOCMapping objects
        """
        all_mappings = []

        for row in caf_df.iter_rows(named=True):
            occ_id = row.get("occupation_id")
            title_en = row.get("title_en", "")
            related_civ = row.get("related_civilian_occupations")

            # Parse JSON if string
            if isinstance(related_civ, str):
                try:
                    related_civ = json.loads(related_civ)
                except json.JSONDecodeError:
                    related_civ = []

            if not occ_id or not title_en:
                continue

            matches = self.match_single(
                caf_occupation_id=occ_id,
                caf_title=title_en,
                related_civilian=related_civ,
                threshold=threshold,
                limit=limit_per_occupation,
            )
            all_mappings.extend(matches)

            if len(all_mappings) % 100 == 0:
                logger.info("matching_progress", matched_so_far=len(all_mappings))

        logger.info("matching_complete", total_mappings=len(all_mappings))
        return all_mappings


def match_caf_to_noc(
    caf_df: pl.DataFrame | None = None,
    noc_df: pl.DataFrame | None = None,
    threshold: float = 50.0,
) -> list[CAFNOCMapping]:
    """Convenience function to match CAF to NOC.

    Args:
        caf_df: CAF occupations DataFrame. Loads from parquet if None.
        noc_df: NOC DataFrame. Loads from parquet if None.
        threshold: Minimum fuzzy score.

    Returns:
        List of CAFNOCMapping objects.
    """
    if caf_df is None:
        caf_df = pl.read_parquet("data/gold/dim_caf_occupation.parquet")

    matcher = CAFNOCMatcher(noc_df)
    return matcher.match_all(caf_df, threshold=threshold)
```

Update `__init__.py`:
```python
from .matchers import CAFNOCMatcher, match_caf_to_noc, CAFNOCMapping
```
  </action>
  <verify>
    `python -c "from jobforge.external.caf import CAFNOCMatcher, match_caf_to_noc; print('Matcher imported')"`
    `python -c "from jobforge.external.caf.matchers import CAFNOCMapping; m = CAFNOCMapping(caf_occupation_id='pilot', noc_unit_group_id='72600', confidence_score=0.85, match_method='automated_fuzzy', algorithm_version='test', matched_caf_text='Pilot', matched_noc_text='Aircraft pilots', rationale='test'); print('Model works')"`
  </verify>
  <done>CAFNOCMatcher created with rapidfuzz token_sort_ratio, confidence scoring, and full audit trail</done>
</task>

<task type="auto">
  <name>Task 2: Generate bridge table and reference mappings</name>
  <files>
    src/jobforge/ingestion/caf.py
    data/gold/bridge_caf_noc.parquet
    data/reference/caf_noc_mappings.json
  </files>
  <action>
1. **Add bridge ingestion to `caf.py`**:

```python
# Add to caf.py

def ingest_bridge_caf_noc(
    caf_df: pl.DataFrame | None = None,
    noc_df: pl.DataFrame | None = None,
    config: Optional[PipelineConfig] = None,
    threshold: float = 50.0,
    table_name: str = "bridge_caf_noc",
) -> dict:
    """Create CAF-to-NOC bridge table with fuzzy matching.

    Args:
        caf_df: CAF occupations. Loads from parquet if None.
        noc_df: NOC data. Loads from parquet if None.
        config: Pipeline config.
        threshold: Minimum fuzzy score for matches.
        table_name: Output table name.

    Returns:
        Dict with gold_path, row_count, mappings_path.
    """
    from jobforge.external.caf.matchers import match_caf_to_noc, CAFNOCMapping

    if caf_df is None:
        caf_df = pl.read_parquet("data/gold/dim_caf_occupation.parquet")

    # Run matching
    mappings = match_caf_to_noc(caf_df, noc_df, threshold=threshold)

    logger.info("caf_noc_matching_complete", mapping_count=len(mappings))

    # Convert to DataFrame
    rows = []
    for m in mappings:
        rows.append({
            "caf_occupation_id": m.caf_occupation_id,
            "noc_unit_group_id": m.noc_unit_group_id,
            "confidence_score": m.confidence_score,
            "match_method": m.match_method,
            "algorithm_version": m.algorithm_version,
            "fuzzy_score": m.fuzzy_score,
            "matched_caf_text": m.matched_caf_text,
            "matched_noc_text": m.matched_noc_text,
            "matching_factors": json.dumps(m.matching_factors),
            "rationale": m.rationale,
            "verified_by": m.verified_by,
            "verified_at": m.verified_at.isoformat() if m.verified_at else None,
            "created_at": m.created_at.isoformat(),
        })

    df = pl.DataFrame(rows)

    # Write to gold
    gold_path = Path(config.gold_dir if config else "data/gold") / f"{table_name}.parquet"
    gold_path.parent.mkdir(parents=True, exist_ok=True)
    df.write_parquet(gold_path)

    # Save reference JSON for human review
    reference_dir = Path("data/reference")
    reference_dir.mkdir(parents=True, exist_ok=True)
    mappings_path = reference_dir / "caf_noc_mappings.json"

    mappings_data = {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "mapping_count": len(mappings),
        "threshold": threshold,
        "algorithm": "rapidfuzz-3.0-token_sort_ratio",
        "mappings": [m.model_dump(mode="json") for m in mappings],
    }

    with open(mappings_path, 'w', encoding='utf-8') as f:
        json.dump(mappings_data, f, indent=2, ensure_ascii=False)

    logger.info(
        "ingested_bridge_caf_noc",
        table_name=table_name,
        row_count=len(df),
        gold_path=str(gold_path),
        mappings_path=str(mappings_path),
    )

    return {
        "gold_path": gold_path,
        "row_count": len(df),
        "table_name": table_name,
        "mappings_path": mappings_path,
    }
```

2. **Add imports to top of caf.py**:
```python
from datetime import datetime, timezone
```

3. **Run bridge generation**:
```python
from jobforge.ingestion.caf import ingest_bridge_caf_noc
result = ingest_bridge_caf_noc()
print(f"Bridge rows: {result['row_count']}")
print(f"Mappings: {result['mappings_path']}")
```
  </action>
  <verify>
    `python -c "from jobforge.ingestion.caf import ingest_bridge_caf_noc; r = ingest_bridge_caf_noc(); print(f'Rows: {r[\"row_count\"]}')"` - shows mappings
    `ls -la data/gold/bridge_caf_noc.parquet` - file exists
    `ls -la data/reference/caf_noc_mappings.json` - file exists
  </verify>
  <done>bridge_caf_noc.parquet created with confidence-scored matches; caf_noc_mappings.json for human review</done>
</task>

<task type="auto">
  <name>Task 3: Create catalog and tests for bridge</name>
  <files>
    data/catalog/tables/bridge_caf_noc.json
    tests/external/test_caf_matchers.py
  </files>
  <action>
1. **Create `data/catalog/tables/bridge_caf_noc.json`**:
```json
{
  "table_name": "bridge_caf_noc",
  "domain": "caf",
  "description": "Bridge table mapping CAF occupations to NOC unit groups with confidence scores and audit trail",
  "source": "JobForge fuzzy matching",
  "source_url": "https://forces.ca + Statistics Canada NOC",
  "columns": {
    "caf_occupation_id": {"type": "VARCHAR", "description": "CAF occupation identifier", "foreign_key": "dim_caf_occupation.occupation_id"},
    "noc_unit_group_id": {"type": "VARCHAR", "description": "NOC 5-digit unit group code", "foreign_key": "dim_noc.unit_group_id"},
    "confidence_score": {"type": "FLOAT", "description": "Match confidence 0.0-1.0 (user filters, not system)"},
    "match_method": {"type": "VARCHAR", "description": "How match determined: automated_fuzzy, human_verified, human_rejected"},
    "algorithm_version": {"type": "VARCHAR", "description": "Algorithm used e.g., rapidfuzz-3.0-token_sort_ratio"},
    "fuzzy_score": {"type": "FLOAT", "description": "Raw rapidfuzz score 0-100 if automated"},
    "matched_caf_text": {"type": "VARCHAR", "description": "CAF text that was matched (title or related civilian)"},
    "matched_noc_text": {"type": "VARCHAR", "description": "NOC text that was matched (class_title)"},
    "matching_factors": {"type": "VARCHAR", "description": "JSON array of factors contributing to score"},
    "rationale": {"type": "VARCHAR", "description": "Human-readable explanation of match"},
    "verified_by": {"type": "VARCHAR", "description": "'human' if reviewed, null if automated only"},
    "verified_at": {"type": "TIMESTAMP", "description": "When human verification occurred"},
    "created_at": {"type": "TIMESTAMP", "description": "When mapping was created"}
  },
  "relationships": [
    {"table": "dim_caf_occupation", "join": "bridge_caf_noc.caf_occupation_id = dim_caf_occupation.occupation_id", "type": "many-to-one"},
    {"table": "dim_noc", "join": "bridge_caf_noc.noc_unit_group_id = dim_noc.unit_group_id", "type": "many-to-one"}
  ]
}
```

2. **Create `tests/external/test_caf_matchers.py`**:
```python
"""Tests for CAF-NOC matching."""
from pathlib import Path
import json

import polars as pl
import pytest

from jobforge.external.caf.matchers import CAFNOCMatcher, CAFNOCMapping, match_caf_to_noc


class TestCAFNOCMapping:
    """Test CAFNOCMapping model."""

    def test_mapping_creation(self):
        """Test mapping model instantiation."""
        m = CAFNOCMapping(
            caf_occupation_id="pilot",
            noc_unit_group_id="72600",
            confidence_score=0.85,
            match_method="automated_fuzzy",
            algorithm_version="test-1.0",
            matched_caf_text="Pilot",
            matched_noc_text="Aircraft pilots",
            rationale="Test match",
        )
        assert m.caf_occupation_id == "pilot"
        assert m.confidence_score == 0.85
        assert m.match_method == "automated_fuzzy"

    def test_mapping_confidence_bounds(self):
        """Test confidence score must be 0.0-1.0."""
        with pytest.raises(ValueError):
            CAFNOCMapping(
                caf_occupation_id="pilot",
                noc_unit_group_id="72600",
                confidence_score=1.5,  # Invalid
                match_method="automated_fuzzy",
                algorithm_version="test",
                matched_caf_text="Pilot",
                matched_noc_text="Pilots",
                rationale="Test",
            )


class TestCAFNOCMatcher:
    """Test matcher functionality."""

    @pytest.fixture
    def matcher(self):
        """Create matcher with real NOC data."""
        noc_path = Path("data/gold/dim_noc.parquet")
        if not noc_path.exists():
            pytest.skip("dim_noc.parquet not available")
        return CAFNOCMatcher()

    def test_matcher_instantiation(self, matcher):
        """Test matcher can be instantiated."""
        assert len(matcher.noc_titles) > 0

    def test_fuzzy_to_confidence(self, matcher):
        """Test fuzzy score to confidence conversion."""
        # High scores -> high confidence
        assert matcher._fuzzy_to_confidence(100) == 1.0
        assert matcher._fuzzy_to_confidence(90) >= 0.85

        # Medium scores -> medium confidence
        conf_80 = matcher._fuzzy_to_confidence(80)
        assert 0.65 <= conf_80 <= 0.75

        # Low scores -> low confidence
        conf_50 = matcher._fuzzy_to_confidence(50)
        assert conf_50 < 0.5

    def test_match_single_returns_mappings(self, matcher):
        """Test matching a single occupation returns results."""
        mappings = matcher.match_single(
            caf_occupation_id="pilot",
            caf_title="Pilot",
            related_civilian=["airline pilot", "commercial pilot"],
            threshold=50.0,
        )
        # Should find some matches
        assert len(mappings) > 0
        # All should have required fields
        for m in mappings:
            assert m.caf_occupation_id == "pilot"
            assert m.noc_unit_group_id
            assert m.confidence_score > 0
            assert m.rationale


class TestBridgeData:
    """Tests for generated bridge data."""

    @pytest.fixture
    def bridge_df(self):
        """Load bridge table if exists."""
        path = Path("data/gold/bridge_caf_noc.parquet")
        if not path.exists():
            pytest.skip("bridge_caf_noc.parquet not yet generated")
        return pl.read_parquet(path)

    def test_bridge_has_rows(self, bridge_df):
        """Test bridge has mappings."""
        assert len(bridge_df) > 0

    def test_bridge_has_audit_trail(self, bridge_df):
        """Test all rows have audit trail per CONTEXT.md."""
        required_cols = [
            "confidence_score",
            "match_method",
            "algorithm_version",
            "rationale",
        ]
        for col in required_cols:
            assert col in bridge_df.columns, f"Missing audit trail column: {col}"

    def test_bridge_confidence_in_range(self, bridge_df):
        """Test confidence scores are valid."""
        scores = bridge_df["confidence_score"].to_list()
        assert all(0.0 <= s <= 1.0 for s in scores)

    def test_bridge_fk_caf_valid(self, bridge_df):
        """Test caf_occupation_id references valid occupations."""
        caf_path = Path("data/gold/dim_caf_occupation.parquet")
        if not caf_path.exists():
            pytest.skip("dim_caf_occupation.parquet not available")

        caf_df = pl.read_parquet(caf_path)
        valid_ids = set(caf_df["occupation_id"].to_list())
        bridge_ids = set(bridge_df["caf_occupation_id"].to_list())

        invalid = bridge_ids - valid_ids
        assert len(invalid) == 0, f"Invalid caf_occupation_ids: {invalid}"

    def test_bridge_fk_noc_valid(self, bridge_df):
        """Test noc_unit_group_id references valid NOC codes."""
        noc_path = Path("data/gold/dim_noc.parquet")
        if not noc_path.exists():
            pytest.skip("dim_noc.parquet not available")

        noc_df = pl.read_parquet(noc_path)
        valid_ids = set(noc_df["unit_group_id"].to_list())
        bridge_ids = set(bridge_df["noc_unit_group_id"].to_list())

        invalid = bridge_ids - valid_ids
        assert len(invalid) == 0, f"Invalid noc_unit_group_ids: {invalid}"
```
  </action>
  <verify>
    `pytest tests/external/test_caf_matchers.py -v` - tests pass
    `cat data/catalog/tables/bridge_caf_noc.json | python -m json.tool > /dev/null` - valid JSON
    `python -c "import polars as pl; df=pl.read_parquet('data/gold/bridge_caf_noc.parquet'); print(df.columns)"` - shows audit trail columns
  </verify>
  <done>Bridge catalog created; matcher tests pass; FK relationships validated; audit trail verified</done>
</task>

</tasks>

<verification>
1. `python -c "from jobforge.external.caf import CAFNOCMatcher, match_caf_to_noc"` - imports work
2. `pytest tests/external/test_caf_matchers.py -v` - tests pass
3. `ls -la data/gold/bridge_caf_noc.parquet` - file exists
4. `ls -la data/reference/caf_noc_mappings.json` - file exists
5. `python -c "import polars as pl; df=pl.read_parquet('data/gold/bridge_caf_noc.parquet'); print(len(df))"` - shows mapping count
6. Bridge has confidence_score, match_method, algorithm_version, rationale columns (audit trail)
</verification>

<success_criteria>
- CAFNOCMatcher uses rapidfuzz token_sort_ratio for fuzzy matching
- bridge_caf_noc.parquet created with CAF-to-NOC mappings
- All mappings have confidence scores (0.0-1.0)
- Full audit trail: match_method, algorithm_version, fuzzy_score, matched_text, rationale
- caf_noc_mappings.json for human review and verification
- FK relationships validated (caf_occupation_id, noc_unit_group_id)
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-caf-core/15-04-SUMMARY.md`
</output>
