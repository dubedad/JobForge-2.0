---
phase: 15-caf-core
plan: 05
type: execute
wave: 4
depends_on: ["15-03"]
files_modified:
  - src/jobforge/external/caf/matchers.py
  - src/jobforge/ingestion/caf.py
  - data/gold/bridge_caf_ja.parquet
  - data/reference/caf_ja_mappings.json
  - data/catalog/tables/bridge_caf_ja.json
  - tests/external/test_caf_ja_matcher.py
autonomous: true

must_haves:
  truths:
    - "User can find Job Architecture matches for any CAF occupation"
    - "All matches have confidence scores with full audit trail"
    - "Two-level matching: CAF occupations to JA job titles/roles"
    - "Automated matches flagged separately from human-verified"
  artifacts:
    - path: "src/jobforge/external/caf/matchers.py"
      provides: "Extended matcher with JA matching"
      exports: ["CAFJAMatcher", "match_caf_to_ja", "CAFJAMapping"]
    - path: "data/gold/bridge_caf_ja.parquet"
      provides: "CAF to Job Architecture bridge with confidence scores"
    - path: "data/reference/caf_ja_mappings.json"
      provides: "Human-reviewable JA mapping file"
  key_links:
    - from: "data/gold/bridge_caf_ja.parquet"
      to: "data/gold/dim_caf_occupation.parquet"
      via: "caf_occupation_id foreign key"
      pattern: "caf_occupation_id"
    - from: "data/gold/bridge_caf_ja.parquet"
      to: "data/gold/dim_job_architecture.parquet"
      via: "ja_job_title_id foreign key"
      pattern: "ja_job_title_id"
---

<objective>
Create CAF-to-Job Architecture bridge table with fuzzy matching and confidence scoring.

Purpose: Enable users to find Job Architecture equivalents for CAF occupations. This supports career transition planning by mapping military careers to federal public service job classifications.

Output: bridge_caf_ja.parquet with confidence-scored matches, caf_ja_mappings.json for human verification, JA matcher extension.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-caf-core/15-CONTEXT.md
@.planning/phases/15-caf-core/15-RESEARCH.md

# Prior plan output
@.planning/phases/15-caf-core/15-03-SUMMARY.md
@.planning/phases/15-caf-core/15-04-SUMMARY.md

# Existing patterns
@src/jobforge/external/caf/matchers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend matchers.py with JA matching</name>
  <files>
    src/jobforge/external/caf/matchers.py
  </files>
  <action>
Add Job Architecture matching to `src/jobforge/external/caf/matchers.py`:

```python
# Add these classes after CAFNOCMapping and CAFNOCMatcher


class CAFJAMapping(BaseModel):
    """Single CAF-to-Job Architecture mapping with confidence and audit trail.

    Per CONTEXT.md: Two-level matching - CAF careers to JA job roles/titles.
    """
    # Keys
    caf_occupation_id: str = Field(description="FK to dim_caf_occupation")
    ja_job_title_id: str = Field(description="FK to dim_job_architecture (job_title_id)")

    # Confidence
    confidence_score: float = Field(ge=0.0, le=1.0, description="Overall match confidence")

    # Audit trail
    match_method: Literal["automated_fuzzy", "human_verified", "human_rejected"]
    algorithm_version: str
    fuzzy_score: float | None = None
    matched_caf_text: str = Field(description="CAF text that was matched")
    matched_ja_text: str = Field(description="JA text that was matched (job_title)")
    matching_factors: list[str] = Field(default_factory=list)
    rationale: str

    # JA context
    ja_job_function: str | None = Field(default=None, description="JA job function for context")
    ja_job_family: str | None = Field(default=None, description="JA job family for context")

    # Verification
    verified_by: str | None = None
    verified_at: datetime | None = None

    # Provenance
    created_at: datetime = Field(default_factory=utc_now)


class CAFJAMatcher:
    """Matches CAF occupations to Job Architecture titles.

    Per CONTEXT.md: Two-level matching
    - CAF individual careers -> JA job roles/titles (primary)
    - JA context (job_function, job_family) captured for filtering
    """

    ALGORITHM_VERSION = "rapidfuzz-3.0-token_sort_ratio"

    def __init__(self, ja_df: pl.DataFrame | None = None):
        """Initialize matcher with Job Architecture data.

        Args:
            ja_df: DataFrame with dim_job_architecture data. Loads from parquet if None.
        """
        if ja_df is None:
            ja_path = Path("data/gold/dim_job_architecture.parquet")
            if not ja_path.exists():
                raise FileNotFoundError(f"dim_job_architecture.parquet not found at {ja_path}")
            ja_df = pl.read_parquet(ja_path)

        self.ja_df = ja_df

        # Build lookup structures
        # Job Architecture has: job_title_id, job_title, job_function, job_family
        self.ja_records = ja_df.select([
            "job_title_id", "job_title", "job_function", "job_family"
        ]).to_dicts()
        self.ja_title_list = [r["job_title"] for r in self.ja_records]
        self.ja_title_map = {r["job_title"]: r for r in self.ja_records}

    def _fuzzy_to_confidence(self, fuzzy_score: float) -> float:
        """Convert rapidfuzz score to confidence (same as NOC matcher)."""
        if fuzzy_score >= 90:
            return 0.85 + (fuzzy_score - 90) * 0.015
        elif fuzzy_score >= 80:
            return 0.70 + (fuzzy_score - 80) * 0.015
        elif fuzzy_score >= 70:
            return 0.55 + (fuzzy_score - 70) * 0.015
        else:
            return fuzzy_score / 100.0 * 0.55

    def match_single(
        self,
        caf_occupation_id: str,
        caf_title: str,
        related_civilian: list[str] | None = None,
        threshold: float = 50.0,
        limit: int = 5,
    ) -> list[CAFJAMapping]:
        """Match single CAF occupation to Job Architecture titles.

        Strategy:
        1. Match related_civilian_occupations against JA titles (higher confidence)
        2. Match CAF title directly against JA titles
        3. Return union of matches with JA context (job_function, job_family)

        Args:
            caf_occupation_id: CAF occupation ID
            caf_title: CAF occupation title (EN)
            related_civilian: List of related civilian occupations
            threshold: Minimum fuzzy score
            limit: Max matches per source

        Returns:
            List of CAFJAMapping objects sorted by confidence.
        """
        mappings = []
        seen_ja_ids = set()

        # Strategy 1: Match from related_civilian_occupations
        if related_civilian:
            for civ_occ in related_civilian:
                matches = process.extract(
                    civ_occ,
                    self.ja_title_list,
                    scorer=fuzz.token_sort_ratio,
                    score_cutoff=threshold,
                    limit=limit,
                )
                for match_text, score, _ in matches:
                    ja_record = self.ja_title_map.get(match_text, {})
                    ja_id = ja_record.get("job_title_id")

                    if ja_id and ja_id not in seen_ja_ids:
                        seen_ja_ids.add(ja_id)
                        mappings.append(CAFJAMapping(
                            caf_occupation_id=caf_occupation_id,
                            ja_job_title_id=ja_id,
                            confidence_score=self._fuzzy_to_confidence(score),
                            match_method="automated_fuzzy",
                            algorithm_version=self.ALGORITHM_VERSION,
                            fuzzy_score=score,
                            matched_caf_text=civ_occ,
                            matched_ja_text=match_text,
                            matching_factors=[
                                "related_civilian_match",
                                f"fuzzy_score={score:.1f}",
                            ],
                            rationale=f"Matched CAF related civilian '{civ_occ}' to JA '{match_text}' with {score:.1f}% similarity",
                            ja_job_function=ja_record.get("job_function"),
                            ja_job_family=ja_record.get("job_family"),
                        ))

        # Strategy 2: Match from CAF title directly
        title_matches = process.extract(
            caf_title,
            self.ja_title_list,
            scorer=fuzz.token_sort_ratio,
            score_cutoff=threshold,
            limit=limit,
        )
        for match_text, score, _ in title_matches:
            ja_record = self.ja_title_map.get(match_text, {})
            ja_id = ja_record.get("job_title_id")

            if ja_id and ja_id not in seen_ja_ids:
                seen_ja_ids.add(ja_id)
                conf = self._fuzzy_to_confidence(score) * 0.9  # Lower for title-only
                mappings.append(CAFJAMapping(
                    caf_occupation_id=caf_occupation_id,
                    ja_job_title_id=ja_id,
                    confidence_score=conf,
                    match_method="automated_fuzzy",
                    algorithm_version=self.ALGORITHM_VERSION,
                    fuzzy_score=score,
                    matched_caf_text=caf_title,
                    matched_ja_text=match_text,
                    matching_factors=[
                        "title_direct_match",
                        f"fuzzy_score={score:.1f}",
                        "confidence_adjusted_0.9x",
                    ],
                    rationale=f"Matched CAF title '{caf_title}' to JA '{match_text}' with {score:.1f}% similarity (0.9x)",
                    ja_job_function=ja_record.get("job_function"),
                    ja_job_family=ja_record.get("job_family"),
                ))

        mappings.sort(key=lambda m: m.confidence_score, reverse=True)
        return mappings

    def match_all(
        self,
        caf_df: pl.DataFrame,
        threshold: float = 50.0,
        limit_per_occupation: int = 5,
    ) -> list[CAFJAMapping]:
        """Match all CAF occupations to Job Architecture."""
        all_mappings = []

        for row in caf_df.iter_rows(named=True):
            occ_id = row.get("occupation_id")
            title_en = row.get("title_en", "")
            related_civ = row.get("related_civilian_occupations")

            if isinstance(related_civ, str):
                try:
                    related_civ = json.loads(related_civ)
                except json.JSONDecodeError:
                    related_civ = []

            if not occ_id or not title_en:
                continue

            matches = self.match_single(
                caf_occupation_id=occ_id,
                caf_title=title_en,
                related_civilian=related_civ,
                threshold=threshold,
                limit=limit_per_occupation,
            )
            all_mappings.extend(matches)

        logger.info("ja_matching_complete", total_mappings=len(all_mappings))
        return all_mappings


def match_caf_to_ja(
    caf_df: pl.DataFrame | None = None,
    ja_df: pl.DataFrame | None = None,
    threshold: float = 50.0,
) -> list[CAFJAMapping]:
    """Convenience function to match CAF to Job Architecture."""
    if caf_df is None:
        caf_df = pl.read_parquet("data/gold/dim_caf_occupation.parquet")

    matcher = CAFJAMatcher(ja_df)
    return matcher.match_all(caf_df, threshold=threshold)
```

Update `__init__.py` to export new classes:
```python
from .matchers import (
    CAFNOCMatcher, match_caf_to_noc, CAFNOCMapping,
    CAFJAMatcher, match_caf_to_ja, CAFJAMapping,
)
```
  </action>
  <verify>
    `python -c "from jobforge.external.caf import CAFJAMatcher, match_caf_to_ja, CAFJAMapping; print('JA matcher exported')"`
    `python -c "from jobforge.external.caf.matchers import CAFJAMapping; m = CAFJAMapping(caf_occupation_id='pilot', ja_job_title_id='JA-001', confidence_score=0.8, match_method='automated_fuzzy', algorithm_version='test', matched_caf_text='Pilot', matched_ja_text='Aviation Manager', rationale='test'); print('Model works')"`
  </verify>
  <done>CAFJAMatcher added to matchers.py with two-level matching and JA context capture</done>
</task>

<task type="auto">
  <name>Task 2: Generate JA bridge table</name>
  <files>
    src/jobforge/ingestion/caf.py
    data/gold/bridge_caf_ja.parquet
    data/reference/caf_ja_mappings.json
  </files>
  <action>
1. **Add JA bridge ingestion to `caf.py`**:

```python
# Add to caf.py after ingest_bridge_caf_noc

def ingest_bridge_caf_ja(
    caf_df: pl.DataFrame | None = None,
    ja_df: pl.DataFrame | None = None,
    config: Optional[PipelineConfig] = None,
    threshold: float = 50.0,
    table_name: str = "bridge_caf_ja",
) -> dict:
    """Create CAF-to-Job Architecture bridge table with fuzzy matching.

    Args:
        caf_df: CAF occupations. Loads from parquet if None.
        ja_df: Job Architecture data. Loads from parquet if None.
        config: Pipeline config.
        threshold: Minimum fuzzy score.
        table_name: Output table name.

    Returns:
        Dict with gold_path, row_count, mappings_path.
    """
    from jobforge.external.caf.matchers import match_caf_to_ja, CAFJAMapping

    if caf_df is None:
        caf_df = pl.read_parquet("data/gold/dim_caf_occupation.parquet")

    # Run matching
    mappings = match_caf_to_ja(caf_df, ja_df, threshold=threshold)

    logger.info("caf_ja_matching_complete", mapping_count=len(mappings))

    # Convert to DataFrame
    rows = []
    for m in mappings:
        rows.append({
            "caf_occupation_id": m.caf_occupation_id,
            "ja_job_title_id": m.ja_job_title_id,
            "confidence_score": m.confidence_score,
            "match_method": m.match_method,
            "algorithm_version": m.algorithm_version,
            "fuzzy_score": m.fuzzy_score,
            "matched_caf_text": m.matched_caf_text,
            "matched_ja_text": m.matched_ja_text,
            "matching_factors": json.dumps(m.matching_factors),
            "rationale": m.rationale,
            "ja_job_function": m.ja_job_function,
            "ja_job_family": m.ja_job_family,
            "verified_by": m.verified_by,
            "verified_at": m.verified_at.isoformat() if m.verified_at else None,
            "created_at": m.created_at.isoformat(),
        })

    df = pl.DataFrame(rows) if rows else pl.DataFrame()

    # Write to gold
    gold_path = Path(config.gold_dir if config else "data/gold") / f"{table_name}.parquet"
    gold_path.parent.mkdir(parents=True, exist_ok=True)
    df.write_parquet(gold_path)

    # Save reference JSON for human review
    reference_dir = Path("data/reference")
    reference_dir.mkdir(parents=True, exist_ok=True)
    mappings_path = reference_dir / "caf_ja_mappings.json"

    mappings_data = {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "mapping_count": len(mappings),
        "threshold": threshold,
        "algorithm": "rapidfuzz-3.0-token_sort_ratio",
        "mappings": [m.model_dump(mode="json") for m in mappings],
    }

    with open(mappings_path, 'w', encoding='utf-8') as f:
        json.dump(mappings_data, f, indent=2, ensure_ascii=False)

    logger.info(
        "ingested_bridge_caf_ja",
        table_name=table_name,
        row_count=len(df),
        gold_path=str(gold_path),
        mappings_path=str(mappings_path),
    )

    return {
        "gold_path": gold_path,
        "row_count": len(df),
        "table_name": table_name,
        "mappings_path": mappings_path,
    }
```

2. **Run bridge generation**:
```python
from jobforge.ingestion.caf import ingest_bridge_caf_ja
result = ingest_bridge_caf_ja()
print(f"JA Bridge rows: {result['row_count']}")
```
  </action>
  <verify>
    `python -c "from jobforge.ingestion.caf import ingest_bridge_caf_ja; r = ingest_bridge_caf_ja(); print(f'Rows: {r[\"row_count\"]}')"` - shows mappings
    `ls -la data/gold/bridge_caf_ja.parquet` - file exists
    `ls -la data/reference/caf_ja_mappings.json` - file exists
  </verify>
  <done>bridge_caf_ja.parquet created; caf_ja_mappings.json for human review</done>
</task>

<task type="auto">
  <name>Task 3: Create catalog and tests for JA bridge</name>
  <files>
    data/catalog/tables/bridge_caf_ja.json
    tests/external/test_caf_ja_matcher.py
  </files>
  <action>
1. **Create `data/catalog/tables/bridge_caf_ja.json`**:
```json
{
  "table_name": "bridge_caf_ja",
  "domain": "caf",
  "description": "Bridge table mapping CAF occupations to Job Architecture titles with confidence scores",
  "source": "JobForge fuzzy matching",
  "source_url": "https://forces.ca + Job Architecture",
  "columns": {
    "caf_occupation_id": {"type": "VARCHAR", "description": "CAF occupation identifier", "foreign_key": "dim_caf_occupation.occupation_id"},
    "ja_job_title_id": {"type": "VARCHAR", "description": "Job Architecture job title ID", "foreign_key": "dim_job_architecture.job_title_id"},
    "confidence_score": {"type": "FLOAT", "description": "Match confidence 0.0-1.0"},
    "match_method": {"type": "VARCHAR", "description": "How match determined: automated_fuzzy, human_verified, human_rejected"},
    "algorithm_version": {"type": "VARCHAR", "description": "Algorithm used"},
    "fuzzy_score": {"type": "FLOAT", "description": "Raw rapidfuzz score 0-100"},
    "matched_caf_text": {"type": "VARCHAR", "description": "CAF text that was matched"},
    "matched_ja_text": {"type": "VARCHAR", "description": "JA text that was matched (job_title)"},
    "matching_factors": {"type": "VARCHAR", "description": "JSON array of factors contributing to score"},
    "rationale": {"type": "VARCHAR", "description": "Human-readable explanation"},
    "ja_job_function": {"type": "VARCHAR", "description": "JA job function for context"},
    "ja_job_family": {"type": "VARCHAR", "description": "JA job family for context"},
    "verified_by": {"type": "VARCHAR", "description": "'human' if reviewed, null if automated"},
    "verified_at": {"type": "TIMESTAMP", "description": "When verification occurred"},
    "created_at": {"type": "TIMESTAMP", "description": "When mapping was created"}
  },
  "relationships": [
    {"table": "dim_caf_occupation", "join": "bridge_caf_ja.caf_occupation_id = dim_caf_occupation.occupation_id", "type": "many-to-one"},
    {"table": "dim_job_architecture", "join": "bridge_caf_ja.ja_job_title_id = dim_job_architecture.job_title_id", "type": "many-to-one"}
  ]
}
```

2. **Create `tests/external/test_caf_ja_matcher.py`**:
```python
"""Tests for CAF-JA matching."""
from pathlib import Path
import json

import polars as pl
import pytest

from jobforge.external.caf.matchers import CAFJAMatcher, CAFJAMapping, match_caf_to_ja


class TestCAFJAMapping:
    """Test CAFJAMapping model."""

    def test_mapping_creation(self):
        """Test mapping model instantiation."""
        m = CAFJAMapping(
            caf_occupation_id="pilot",
            ja_job_title_id="JA-001",
            confidence_score=0.80,
            match_method="automated_fuzzy",
            algorithm_version="test-1.0",
            matched_caf_text="Pilot",
            matched_ja_text="Aviation Manager",
            rationale="Test match",
            ja_job_function="Operations",
            ja_job_family="Transportation",
        )
        assert m.caf_occupation_id == "pilot"
        assert m.ja_job_title_id == "JA-001"
        assert m.ja_job_function == "Operations"


class TestCAFJAMatcher:
    """Test JA matcher functionality."""

    @pytest.fixture
    def matcher(self):
        """Create matcher with real JA data."""
        ja_path = Path("data/gold/dim_job_architecture.parquet")
        if not ja_path.exists():
            pytest.skip("dim_job_architecture.parquet not available")
        return CAFJAMatcher()

    def test_matcher_instantiation(self, matcher):
        """Test matcher can be instantiated."""
        assert len(matcher.ja_records) > 0

    def test_match_single_returns_mappings(self, matcher):
        """Test matching returns results."""
        mappings = matcher.match_single(
            caf_occupation_id="pilot",
            caf_title="Pilot",
            related_civilian=["aviation manager", "flight operations"],
            threshold=50.0,
        )
        # May or may not find matches depending on JA content
        # Just verify no errors and correct types
        for m in mappings:
            assert m.caf_occupation_id == "pilot"
            assert m.ja_job_title_id
            assert m.confidence_score > 0


class TestJABridgeData:
    """Tests for generated JA bridge data."""

    @pytest.fixture
    def bridge_df(self):
        """Load bridge table if exists."""
        path = Path("data/gold/bridge_caf_ja.parquet")
        if not path.exists():
            pytest.skip("bridge_caf_ja.parquet not yet generated")
        return pl.read_parquet(path)

    def test_bridge_has_audit_trail(self, bridge_df):
        """Test all rows have audit trail."""
        if len(bridge_df) == 0:
            pytest.skip("No JA mappings found (may be expected)")

        required_cols = [
            "confidence_score",
            "match_method",
            "algorithm_version",
            "rationale",
            "ja_job_function",
            "ja_job_family",
        ]
        for col in required_cols:
            assert col in bridge_df.columns, f"Missing column: {col}"

    def test_bridge_confidence_in_range(self, bridge_df):
        """Test confidence scores are valid."""
        if len(bridge_df) == 0:
            pytest.skip("No JA mappings")

        scores = bridge_df["confidence_score"].to_list()
        assert all(0.0 <= s <= 1.0 for s in scores)

    def test_bridge_fk_caf_valid(self, bridge_df):
        """Test caf_occupation_id references valid occupations."""
        if len(bridge_df) == 0:
            pytest.skip("No JA mappings")

        caf_path = Path("data/gold/dim_caf_occupation.parquet")
        if not caf_path.exists():
            pytest.skip("dim_caf_occupation.parquet not available")

        caf_df = pl.read_parquet(caf_path)
        valid_ids = set(caf_df["occupation_id"].to_list())
        bridge_ids = set(bridge_df["caf_occupation_id"].to_list())

        invalid = bridge_ids - valid_ids
        assert len(invalid) == 0, f"Invalid caf_occupation_ids: {invalid}"

    def test_bridge_fk_ja_valid(self, bridge_df):
        """Test ja_job_title_id references valid JA records."""
        if len(bridge_df) == 0:
            pytest.skip("No JA mappings")

        ja_path = Path("data/gold/dim_job_architecture.parquet")
        if not ja_path.exists():
            pytest.skip("dim_job_architecture.parquet not available")

        ja_df = pl.read_parquet(ja_path)
        valid_ids = set(ja_df["job_title_id"].to_list())
        bridge_ids = set(bridge_df["ja_job_title_id"].to_list())

        invalid = bridge_ids - valid_ids
        assert len(invalid) == 0, f"Invalid ja_job_title_ids: {invalid}"
```
  </action>
  <verify>
    `pytest tests/external/test_caf_ja_matcher.py -v` - tests pass
    `cat data/catalog/tables/bridge_caf_ja.json | python -m json.tool > /dev/null` - valid JSON
    `python -c "import polars as pl; df=pl.read_parquet('data/gold/bridge_caf_ja.parquet'); print(f'JA Bridge columns: {df.columns}')"` - shows JA context columns
  </verify>
  <done>JA bridge catalog created; tests pass; JA context (job_function, job_family) captured in bridge</done>
</task>

</tasks>

<verification>
1. `python -c "from jobforge.external.caf import CAFJAMatcher, match_caf_to_ja"` - imports work
2. `pytest tests/external/test_caf_ja_matcher.py -v` - tests pass
3. `ls -la data/gold/bridge_caf_ja.parquet` - file exists
4. `ls -la data/reference/caf_ja_mappings.json` - file exists
5. Bridge has ja_job_function, ja_job_family columns for context filtering
6. FK relationships valid
</verification>

<success_criteria>
- CAFJAMatcher added with two-level matching capability
- bridge_caf_ja.parquet created with CAF-to-JA mappings
- JA context captured (job_function, job_family) for filtering
- Full audit trail on all mappings
- caf_ja_mappings.json for human review
- FK relationships validated
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-caf-core/15-05-SUMMARY.md`
</output>
