---
phase: 03-wiq-semantic-model
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/jobforge/semantic/schema.py
  - src/jobforge/semantic/validator.py
  - src/jobforge/semantic/__init__.py
  - data/catalog/schemas/wiq_schema.json
autonomous: true

must_haves:
  truths:
    - "WiQ schema defines all dimension and fact tables with explicit relationships"
    - "DIM NOC connects to Element, Oasis, and COPS tables with 1:M cardinality"
    - "DIM Occupations connects to Job Architecture with 1:M cardinality"
    - "Relationship definitions are machine-readable JSON"
    - "Schema validates with no circular relationships"
  artifacts:
    - path: "src/jobforge/semantic/schema.py"
      provides: "WiQ schema definition with all relationships"
      exports: ["build_wiq_schema", "WIQ_RELATIONSHIPS"]
      min_lines: 100
    - path: "src/jobforge/semantic/validator.py"
      provides: "Schema validation functions"
      exports: ["validate_schema", "ValidationResult"]
      min_lines: 60
    - path: "data/catalog/schemas/wiq_schema.json"
      provides: "Machine-readable schema export for Phase 4"
      contains: "relationships"
  key_links:
    - from: "src/jobforge/semantic/schema.py"
      to: "src/jobforge/semantic/introspect.py"
      via: "introspect_all_gold_tables call"
      pattern: "introspect_all_gold_tables"
    - from: "src/jobforge/semantic/schema.py"
      to: "src/jobforge/semantic/models.py"
      via: "imports Relationship, SemanticSchema"
      pattern: "from.*models import"
    - from: "src/jobforge/semantic/validator.py"
      to: "duckdb"
      via: "cardinality validation queries"
      pattern: "COUNT.*DISTINCT"
---

<objective>
Define the complete WiQ semantic schema with all table relationships and validate for Power BI compatibility.

Purpose: Create the actual WiQ dimensional model that Phase 4 will deploy to Power BI. This includes defining relationships between DIM NOC (the hub) and its satellite tables (Element, Oasis, COPS), plus the Job Architecture / DIM Occupations relationship. Schema must be validated for Power BI consumption (no cycles, correct cardinality).

Output: `src/jobforge/semantic/schema.py` (schema builder), `src/jobforge/semantic/validator.py` (validation), and `data/catalog/schemas/wiq_schema.json` (exported schema for Phase 4).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/03-wiq-semantic-model/03-RESEARCH.md
@.planning/phases/03-wiq-semantic-model/03-01-SUMMARY.md

# From Plan 01
@src/jobforge/semantic/models.py
@src/jobforge/semantic/introspect.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define WiQ schema with relationships</name>
  <files>src/jobforge/semantic/schema.py</files>
  <action>
Create the WiQ schema definition with all dimensional relationships.

In `src/jobforge/semantic/schema.py`:

1. Import dependencies:
   - from jobforge.semantic.models import Relationship, Cardinality, CrossFilterDirection, SemanticSchema, Table
   - from jobforge.semantic.introspect import introspect_all_gold_tables
   - from jobforge.pipeline.config import PipelineConfig

2. Define WIQ_RELATIONSHIPS as a list of Relationship objects:

   DIM NOC as hub connecting to attribute tables (all 1:*):
   - dim_noc.unit_group_id -> oasis_abilities.unit_group_id (1:*)
   - dim_noc.unit_group_id -> oasis_knowledges.unit_group_id (1:*)
   - dim_noc.unit_group_id -> oasis_skills.unit_group_id (1:*)
   - dim_noc.unit_group_id -> oasis_workactivities.unit_group_id (1:*)
   - dim_noc.unit_group_id -> oasis_workcontext.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_additional_information.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_employment_requirements.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_example_titles.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_exclusions.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_labels.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_lead_statement.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_main_duties.unit_group_id (1:*)
   - dim_noc.unit_group_id -> element_workplaces_employers.unit_group_id (1:*)

   DIM NOC to COPS fact tables (all 1:*):
   - dim_noc.unit_group_id -> cops_employment.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_employment_growth.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_immigration.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_other_replacement.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_other_seekers.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_retirement_rates.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_retirements.unit_group_id (1:*)
   - dim_noc.unit_group_id -> cops_school_leavers.unit_group_id (1:*)

   Job Architecture relationship:
   - dim_occupations.occupation_id -> job_architecture.occupation_id (1:*)

   All relationships should use:
   - cardinality=Cardinality.ONE_TO_MANY
   - cross_filter_direction=CrossFilterDirection.SINGLE
   - is_active=True

3. Define `build_wiq_schema(config: PipelineConfig | None = None) -> SemanticSchema`:
   - Introspect all gold tables via introspect_all_gold_tables(config)
   - Mark primary keys on dimension tables:
     - dim_noc: unit_group_id
     - dim_occupations: occupation_id
   - Mark foreign keys on attribute/fact tables (unit_group_id, occupation_id)
   - Create SemanticSchema with name="WiQ", tables, and WIQ_RELATIONSHIPS
   - Return the schema (not yet validated - validation is separate)

4. Define `export_schema_json(schema: SemanticSchema, output_path: Path) -> Path`:
   - Write schema.to_json() to output_path
   - Return the path written to
  </action>
  <verify>
    Run: `python -c "from jobforge.semantic.schema import build_wiq_schema; s = build_wiq_schema(); print(f'{len(s.tables)} tables, {len(s.relationships)} relationships')"`
    Expected: "25 tables, 22 relationships" (or similar counts)
  </verify>
  <done>
    WiQ schema defines all tables and relationships, with DIM NOC as hub connecting to all attribute/fact tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create schema validator</name>
  <files>src/jobforge/semantic/validator.py</files>
  <action>
Create validation utilities to ensure schema is Power BI compatible.

In `src/jobforge/semantic/validator.py`:

1. Import dependencies:
   - from collections import defaultdict
   - from dataclasses import dataclass, field
   - from pathlib import Path
   - import duckdb
   - from jobforge.semantic.models import SemanticSchema, Relationship
   - from jobforge.pipeline.config import PipelineConfig

2. Define ValidationResult dataclass:
   - is_valid: bool
   - errors: list[str] = field(default_factory=list)
   - warnings: list[str] = field(default_factory=list)

3. Define `check_no_circular_relationships(schema: SemanticSchema) -> list[str]`:
   - Build directed graph from relationships (from_table -> to_table)
   - Use DFS to detect cycles
   - Return list of error messages (empty if no cycles)

4. Define `check_relationship_columns_exist(schema: SemanticSchema) -> list[str]`:
   - For each relationship:
     - Find from_table and to_table in schema.tables
     - Check from_column exists in from_table.columns
     - Check to_column exists in to_table.columns
   - Return list of error messages for missing columns

5. Define `check_cardinality_valid(schema: SemanticSchema, config: PipelineConfig | None = None) -> list[str]`:
   - For relationships with cardinality ONE_TO_MANY:
     - The "one" side (from_table.from_column) should have unique values
     - Query: SELECT COUNT(*) = COUNT(DISTINCT {col}) FROM '{parquet_path}'
   - Return list of warnings if uniqueness check fails (warning, not error - data may have legitimate duplicates)

6. Define `check_column_types_compatible(schema: SemanticSchema) -> list[str]`:
   - For each relationship:
     - Get from_column type and to_column type
     - Check they are compatible (same base type)
   - Return list of errors for type mismatches

7. Define `validate_schema(schema: SemanticSchema, config: PipelineConfig | None = None) -> ValidationResult`:
   - Run all checks: no_circular, columns_exist, cardinality, types_compatible
   - Collect errors and warnings
   - Return ValidationResult with is_valid=(no errors)

Do NOT make cardinality failures block validation - they're warnings. The relationship may still work in Power BI.
  </action>
  <verify>
    Run: `python -c "from jobforge.semantic.schema import build_wiq_schema; from jobforge.semantic.validator import validate_schema; r = validate_schema(build_wiq_schema()); print(f'Valid: {r.is_valid}, Errors: {len(r.errors)}, Warnings: {len(r.warnings)}')"`
    Expected: "Valid: True, Errors: 0, Warnings: N" (N may be > 0 for cardinality warnings)
  </verify>
  <done>
    Validator checks for cycles, missing columns, type compatibility, and cardinality; returns structured ValidationResult
  </done>
</task>

<task type="auto">
  <name>Task 3: Export validated schema and update module exports</name>
  <files>src/jobforge/semantic/__init__.py, data/catalog/schemas/wiq_schema.json</files>
  <action>
Export the validated WiQ schema to JSON and update module exports.

1. Update `src/jobforge/semantic/__init__.py`:
   - Add imports from schema.py: build_wiq_schema, WIQ_RELATIONSHIPS, export_schema_json
   - Add imports from validator.py: validate_schema, ValidationResult
   - Add imports from introspect.py: introspect_all_gold_tables, introspect_parquet_schema
   - Update __all__ list to export all public symbols

2. Create a Python script (in-line execution, not a file) to:
   - Build WiQ schema: schema = build_wiq_schema()
   - Validate schema: result = validate_schema(schema)
   - If valid (or only warnings): mark schema.validated = True, schema.validation_date = now
   - Export to JSON: export_schema_json(schema, Path("data/catalog/schemas/wiq_schema.json"))
   - Print validation summary

3. Ensure `data/catalog/schemas/` directory exists (mkdir -p)

The exported wiq_schema.json must contain:
- "name": "WiQ"
- "tables": [...] with all 25 tables and their columns
- "relationships": [...] with all 22 relationships
- "validated": true
- "validation_date": ISO timestamp

This JSON file is the input for Phase 4 (Power BI deployment).
  </action>
  <verify>
    Run: `python -c "import json; from pathlib import Path; data = json.loads(Path('data/catalog/schemas/wiq_schema.json').read_text()); print(f'Schema: {data[\"name\"]}, Tables: {len(data[\"tables\"])}, Relationships: {len(data[\"relationships\"])}, Validated: {data[\"validated\"]}')"`
    Expected: "Schema: WiQ, Tables: 25, Relationships: 22, Validated: True"
  </verify>
  <done>
    wiq_schema.json exists in data/catalog/schemas/ with complete validated schema ready for Phase 4 consumption
  </done>
</task>

</tasks>

<verification>
1. Schema builds without error: `python -c "from jobforge.semantic import build_wiq_schema; build_wiq_schema()"`
2. Validation passes: `python -c "from jobforge.semantic import build_wiq_schema, validate_schema; print(validate_schema(build_wiq_schema()))"`
3. JSON export exists and is valid: `python -c "import json; json.loads(open('data/catalog/schemas/wiq_schema.json').read())"`
4. All relationships are Power BI compatible (1:* with single direction)
</verification>

<success_criteria>
1. WiQ schema defines all 25 gold tables with correct TableType classification
2. 22 relationships defined: DIM NOC -> 21 tables + DIM Occupations -> Job Architecture
3. Schema validation passes with no errors (warnings OK for cardinality)
4. wiq_schema.json exists at data/catalog/schemas/wiq_schema.json
5. JSON contains machine-readable relationship definitions for Phase 4 deployment
6. No circular relationships detected
7. All FK/PK column references validated to exist
</success_criteria>

<output>
After completion, create `.planning/phases/03-wiq-semantic-model/03-02-SUMMARY.md`
</output>
